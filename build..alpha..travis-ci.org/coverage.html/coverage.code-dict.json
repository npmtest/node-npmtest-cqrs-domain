{"/home/travis/build/npmtest/node-npmtest-cqrs-domain/test.js":"/* istanbul instrument in package npmtest_cqrs_domain */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireExampleJsFromReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-cqrs-domain/lib.npmtest_cqrs_domain.js":"/* istanbul instrument in package npmtest_cqrs_domain */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_cqrs_domain = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_cqrs_domain = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-cqrs-domain/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-cqrs-domain && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_cqrs_domain */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_cqrs_domain\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_cqrs_domain.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_cqrs_domain.rollup.js'] =\n            local.assetsDict['/assets.npmtest_cqrs_domain.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_cqrs_domain.__dirname + '/lib.npmtest_cqrs_domain.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-cqrs-domain/node_modules/cqrs-domain/index.js":"'use strict';\n\nvar Domain = require('./lib/domain'),\n  ValidationError = require('./lib/errors/validationError'),\n  BusinessRuleError = require('./lib/errors/businessRuleError'),\n  AggregateConcurrencyError = require('./lib/errors/aggregateConcurrencyError'),\n  AggregateDestroyedError = require('./lib/errors/aggregateDestroyedError'),\n  ConcurrencyError = require('./lib/errors/concurrencyError'),\n  DuplicateCommandError = require('./lib/errors/duplicateCommandError'),\n  _ = require('lodash'),\n  fs = require('fs'),\n  path = require('path');\n\nfunction domain (options) {\n  return new Domain(options);\n}\n\n/**\n * Calls the constructor.\n * @param  {Object} klass Constructor function.\n * @param  {Array}  args  Arguments for the constructor function.\n * @return {Object}       The new object.\n */\nfunction construct(klass, args) {\n  function T() {\n    klass.apply(this, arguments[0]);\n  }\n  T.prototype = klass.prototype;\n  return new T(args);\n}\n\nvar files = fs.readdirSync(path.join(__dirname, 'lib/definitions'));\n\nfiles.forEach(function (file) {\n  var name = path.basename(file, '.js');\n  var nameCap = name.charAt(0).toUpperCase() + name.slice(1);\n  domain['define' + nameCap] = function () {\n    return construct(require('./lib/definitions/' + name), _.toArray(arguments));\n  };\n});\n\ndomain.errors = {\n  ValidationError: ValidationError,\n  BusinessRuleError: BusinessRuleError,\n  AggregateConcurrencyError: AggregateConcurrencyError,\n  AggregateDestroyedError: AggregateDestroyedError,\n  ConcurrencyError: ConcurrencyError,\n  DuplicateCommandError: DuplicateCommandError\n};\n\nmodule.exports = domain;\n","/home/travis/build/npmtest/node-npmtest-cqrs-domain/node_modules/cqrs-domain/lib/domain.js":"'use strict';\n\nvar debug = require('debug')('domain'),\n  async = require('async'),\n  util = require('util'),\n  EventEmitter = require('events').EventEmitter,\n  _ = require('lodash'),\n  eventstore = require('eventstore'),\n  aggregatelock = require('./lock'),\n  commandBumper = require('./bumper'),\n  structureLoader = require('./structure/structureLoader'),\n  attachLookupFunctions = require('./structure/treeExtender'),\n  ValidationError = require('./errors/validationError'),\n  BusinessRuleError = require('./errors/businessRuleError'),\n  AggregateConcurrencyError = require('./errors/aggregateConcurrencyError'),\n  AggregateDestroyedError = require('./errors/aggregateDestroyedError'),\n  DuplicateCommandError = require('./errors/duplicateCommandError'),\n  CommandDispatcher = require('./commandDispatcher'),\n  uuid = require('uuid').v4,\n  dotty = require('dotty');\n\nfunction isValidEventStore (obj) {\n  // TODO: check each method's signature?\n  return !!obj && _.every([\n    obj.init, obj.on, obj.getNewId, obj.getFromSnapshot,\n    obj.createSnapshot, obj.setEventToDispatched],\n    function (o) {\n      return _.isFunction(o);\n    }\n  );\n}\n\nfunction createEventStore (options) {\n  if ( _.isFunction(options)) {\n    // This is a factory method.\n    var eventStore = options();\n    if (!isValidEventStore(eventStore)) {\n      var err = new Error('\"options.eventStore\" is not a valid event store factory');\n      debug(err);\n      throw err;\n    }\n    return eventStore;\n  }\n  return eventstore(options);\n}\n\nfunction isValidAggregateLock (obj) {\n  // TODO: check each method's signature?\n  return !!obj && _.every([\n    obj.connect, obj.disconnect, obj.on, obj.getNewId,\n    obj.reserve, obj.getAll, obj.resolve],\n    function (o) {\n      return _.isFunction(o);\n    }\n  );\n}\n\nfunction isValidCommandBumper (obj) {\n  // TODO: check each method's signature?\n  return !!obj && _.every([\n        obj.connect, obj.disconnect, obj.on, obj.getNewId,\n        obj.add],\n      function (o) {\n        return _.isFunction(o);\n      }\n    );\n}\n\nfunction createAggregateLock (options) {\n  if (_.isFunction(options)) {\n    // This is a factory method.\n    var lock = options();\n    if (!isValidAggregateLock(lock)) {\n      var err = new Error('\"options.aggregateLock\" is not a valid aggregate lock factory');\n      debug(err);\n      throw err;\n    }\n  }\n  return aggregatelock.create(options);\n}\n\nfunction createCommandBumper (options) {\n  if (_.isFunction(options)) {\n    // This is a factory method.\n    var bumper = options();\n    if (!isValidCommandBumper(bumper)) {\n      var err = new Error('\"options.deduplication\" is not a valid deduplication store factory');\n      debug(err);\n      throw err;\n    }\n  }\n  return commandBumper.create(options);\n}\n\n/**\n * Domain constructor\n * @param {Object} options The options.\n * @constructor\n */\nfunction Domain(options) {\n  EventEmitter.call(this);\n\n  options = options || {};\n\n  if (!options.domainPath) {\n    var err = new Error('Please provide domainPath in options');\n    debug(err);\n    throw err;\n  }\n\n  options.retryOnConcurrencyTimeout = options.retryOnConcurrencyTimeout || 800;\n\n  options.commandRejectedEventName = options.commandRejectedEventName || 'commandRejected';\n\n  options.snapshotThreshold = options.snapshotThreshold || 100;\n\n  this.eventStore = createEventStore(options.eventStore);\n\n  this.aggregateLock = createAggregateLock(options.aggregateLock);\n\n  if (options.deduplication) {\n    this.commandBumper = createCommandBumper(options.deduplication);\n  }\n\n  this.options = options;\n\n  this.definitions = {\n    command: {\n      id: 'id',\n      name: 'name',\n      aggregateId: 'aggregate.id'\n//      context: 'context.name',        // optional\n//      aggregate: 'aggregate.name',    // optional\n//      payload: 'payload',             // optional\n//      revision: 'revision',           // optional\n//      version: 'version',             // optional\n//      meta: 'meta'                    // optional (will be passed directly to corresponding event(s))\n    },\n    event: {\n      correlationId: 'correlationId',\n      id: 'id',\n      name: 'name',\n      aggregateId: 'aggregate.id',\n//      context: 'context.name',        // optional\n//      aggregate: 'aggregate.name',    // optional\n      payload: 'payload',               // optional\n      revision: 'revision'              // optional\n//      version: 'version',             // optional\n//      meta: 'meta'                    // optional (will be passed directly from corresponding command)\n    }\n  };\n\n  this.idGenerator(function () {\n    return uuid().toString();\n  });\n\n  this.onEvent(function (evt) {\n    debug('emit:', evt);\n  });\n\n  this.extendValidator(function (validator) {\n    debug('no validator extension defined');\n  });\n}\n\nutil.inherits(Domain, EventEmitter);\n\n_.extend(Domain.prototype, {\n\n  /**\n   * Inject definition for command structure.\n   * @param   {Object} definition the definition to be injected\n   * @returns {Domain}            to be able to chain...\n   */\n  defineCommand: function (definition) {\n    if (!definition || !_.isObject(definition)) {\n      var err = new Error('Please pass a valid definition!');\n      debug(err);\n      throw err;\n    }\n\n    this.definitions.command = _.defaults(definition, this.definitions.command);\n    return this;\n  },\n\n  /**\n   * Inject definition for event structure.\n   * @param   {Object} definition the definition to be injected\n   * @returns {Domain}            to be able to chain...\n   */\n  defineEvent: function (definition) {\n    if (!definition || !_.isObject(definition)) {\n      var err = new Error('Please pass a valid definition!');\n      debug(err);\n      throw err;\n    }\n\n    this.definitions.event = _.defaults(definition, this.definitions.event);\n\n    if (this.definitions.event.commitStamp) {\n      this.eventStore.defineEventMappings({\n        commitStamp: this.definitions.event.commitStamp\n      });\n    }\n    return this;\n  },\n\n  /**\n   * Inject idGenerator function.\n   * @param   {Function}  fn The function to be injected.\n   * @returns {Domain}       to be able to chain...\n   */\n  idGenerator: function (fn) {\n    if (!fn || !_.isFunction(fn)) {\n      var err = new Error('Please pass a valid function!');\n      debug(err);\n      throw err;\n    }\n\n    if (fn.length === 1) {\n      this.getNewId = fn;\n      return this;\n    }\n\n    this.getNewId = function (callback) {\n      callback(null, fn());\n    };\n\n    return this;\n  },\n\n  /**\n   * Inject idGenerator function for aggregate id.\n   * @param   {Function}  fn The function to be injected.\n   * @returns {Domain}       to be able to chain...\n   */\n  aggregateIdGenerator: function (fn) {\n    if (!fn || !_.isFunction(fn)) {\n      var err = new Error('Please pass a valid function!');\n      debug(err);\n      throw err;\n    }\n\n    if (fn.length === 1) {\n      this.getNewAggregateId = fn;\n      return this;\n    }\n\n    this.getNewAggregateId = function (callback) {\n      callback(null, fn());\n    };\n\n    return this;\n  },\n\n  /**\n   * Inject function for for event notification.\n   * @param   {Function} fn the function to be injected\n   * @returns {Domain}      to be able to chain...\n   */\n  onEvent: function (fn) {\n    if (!fn || !_.isFunction(fn)) {\n      var err = new Error('Please pass a valid function!');\n      debug(err);\n      throw err;\n    }\n\n    if (fn.length === 1) {\n      fn = _.wrap(fn, function(func, evt, callback) {\n        func(evt);\n        callback(null);\n      });\n    }\n\n    this.onEventHandle = fn;\n\n    return this;\n  },\n\n  /**\n   * Converts an error to the commandRejected event\n   * @param {Object} cmd The command that was handled.\n   * @param {Error}  err The error that occurs.\n   * @returns {Object} The resulting event.\n   */\n  createCommandRejectedEvent: function (cmd, err) {\n    if (!cmd || !_.isObject(cmd)) {\n      var err = new Error('Please pass a valid command!');\n      debug(err);\n      throw err;\n    }\n    if (!err || !_.isObject(err)) {\n      var err = new Error('Please pass a valid error!');\n      debug(err);\n      throw err;\n    }\n\n    var evt = {};\n\n    if (!!this.definitions.command.meta && !!this.definitions.event.meta) {\n      dotty.put(evt, this.definitions.event.meta, dotty.get(cmd, this.definitions.command.meta));\n    }\n\n    dotty.put(evt, this.definitions.event.correlationId, dotty.get(cmd, this.definitions.command.id));\n    dotty.put(evt, this.definitions.event.name, this.options.commandRejectedEventName);\n    dotty.put(evt, this.definitions.event.id, dotty.get(cmd, this.definitions.command.id) + '_rejected');\n    dotty.put(evt, this.definitions.event.aggregateId, dotty.get(cmd, this.definitions.command.aggregateId));\n\n    if (!!this.definitions.command.aggregate && !!this.definitions.event.aggregate) {\n      dotty.put(evt, this.definitions.event.aggregate, dotty.get(cmd, this.definitions.command.aggregate));\n    }\n\n    if (!!this.definitions.command.context && !!this.definitions.event.context) {\n      dotty.put(evt, this.definitions.event.context, dotty.get(cmd, this.definitions.command.context));\n    }\n\n    if (err instanceof ValidationError || err instanceof BusinessRuleError ||\n        err instanceof AggregateDestroyedError || err instanceof AggregateConcurrencyError ||\n        err instanceof DuplicateCommandError) {\n      dotty.put(evt, this.definitions.event.payload, {\n        command: cmd,\n        reason: {\n          name: err.name,\n          message: err.message,\n          more: err.more\n        }\n      });\n    } else {\n      evt = null;\n    }\n\n    return evt;\n  },\n\n  /**\n   * Returns the domain information.\n   * @returns {Object}\n   */\n  getInfo: function () {\n    if (!this.tree) {\n      var err = new Error('Not initialized!');\n      debug(err);\n      throw err;\n    }\n\n    return this.tree.getInfo();\n  },\n\n  /**\n   * Extends the validator instance.\n   * @param   {Function} fn the function to be injected\n   * @returns {Domain}      to be able to chain...\n   */\n  extendValidator: function (fn) {\n    if (!fn || !_.isFunction(fn) || fn.length !== 1) {\n      var err = new Error('Please pass a valid function!');\n      debug(err);\n      throw err;\n    }\n\n    this.validatorExtension = fn;\n\n    return this;\n  },\n\n  /**\n   * Call this function to initialize the domain.\n   * @param {Function} callback the function that will be called when this action has finished [optional]\n   *                            `function(err, warnings){}`\n   */\n  init: function (callback) {\n\n    var self = this;\n\n    var warnings = null;\n\n    async.series([\n      // load domain files...\n      function (callback) {\n        debug('load domain files..');\n        structureLoader(self.options.domainPath, self.validatorExtension, function (err, tree, warns) {\n          if (err) {\n            return callback(err);\n          }\n          warnings = warns;\n\n          if (!tree || _.isEmpty(tree)) return callback(new Error('No structure loaded for ' + self.options.domainPath + '!'));\n\n          self.tree = attachLookupFunctions(tree);\n          callback(null);\n        });\n      },\n\n      // prepare infrastructure...\n      function (callback) {\n        debug('prepare infrastructure...');\n        async.parallel([\n\n          // prepare eventStore...\n          function (callback) {\n            debug('prepare eventStore...');\n\n            self.eventStore.on('connect', function () {\n              self.emit('connect');\n            });\n\n            self.eventStore.on('disconnect', function () {\n              self.emit('disconnect');\n            });\n\n            self.eventStore.init(callback);\n          },\n\n          // prepare aggregateLock...\n          function (callback) {\n            debug('prepare aggregateLock...');\n\n            self.aggregateLock.on('connect', function () {\n              self.emit('connect');\n            });\n\n            self.aggregateLock.on('disconnect', function () {\n              self.emit('disconnect');\n            });\n\n            self.aggregateLock.connect(callback);\n          },\n\n          // prepare commandBumper...\n          function (callback) {\n            if (!self.commandBumper) {\n              return callback(null);\n            }\n            debug('prepare commandBumper...');\n\n            self.commandBumper.on('connect', function () {\n              self.emit('connect');\n            });\n\n            self.commandBumper.on('disconnect', function () {\n              self.emit('disconnect');\n            });\n\n            self.commandBumper.connect(callback);\n          }\n        ], callback);\n      },\n\n      // inject all needed dependencies...\n      function (callback) {\n        debug('inject all needed dependencies...');\n\n        self.commandDispatcher = new CommandDispatcher(self.tree, self.definitions.command, self.commandBumper);\n        self.tree.defineOptions({\n            retryOnConcurrencyTimeout: self.options.retryOnConcurrencyTimeout,\n            snapshotThreshold: self.options.snapshotThreshold,\n            snapshotThresholdMs: self.options.snapshotThresholdMs\n          })\n          .defineCommand(self.definitions.command)\n          .defineEvent(self.definitions.event)\n          .idGenerator(self.getNewId)\n          .useEventStore(self.eventStore)\n          .useAggregateLock(self.aggregateLock);\n\n        if (self.getNewAggregateId) {\n          self.tree.aggregateIdGenerator(self.getNewAggregateId);\n        }\n\n        callback(null);\n      }\n    ], function (err) {\n      if (err) {\n        debug(err);\n      } else {\n        debug('domain inited');\n      }\n      if (callback) callback(err, warnings);\n    });\n  },\n\n  /**\n   * Is called when dispatched a command.\n   * @param {Object}   cmd              the command object\n   * @param {Error}    err              the error\n   * @param {Array}    eventsToDispatch the events to dispatch\n   * @param {Object}   aggregateData    the aggregate data\n   * @param {Object}   meta             the meta infos\n   * @param {Function} callback         the function that will be called when this action has finished [optional]\n   *                                    `function(err, evts, aggregateData, meta){}` evts is of type Array, aggregateData and meta are an object\n   */\n  onDispatched: function (cmd, err, eventsToDispatch, aggregateData, meta, callback) {\n    var self = this;\n\n    if (err) {\n      debug(err);\n      var cmdRejEvt = this.createCommandRejectedEvent(cmd, err);\n      if (cmdRejEvt) {\n        this.onEventHandle(cmdRejEvt, function (err) { if (err) { debug(err); } });\n\n        if (callback) {\n          try {\n            callback(err, [cmdRejEvt], aggregateData || null, meta || null);\n          } catch (e) {\n            debug(e);\n            console.log(e.stack);\n            process.emit('uncaughtException', e);\n          }\n        }\n        return;\n      }\n\n      if (callback) {\n        try {\n          callback(err, null, aggregateData, meta);\n        } catch (e) {\n          debug(e);\n          console.log(e.stack);\n          process.emit('uncaughtException', e);\n        }\n      }\n      return;\n    }\n\n    var evts = [];\n    if (!eventsToDispatch || !_.isArray(eventsToDispatch)) {\n      debug('seams to be something from a custom command handler');\n      if (callback) {\n        try {\n          callback.apply(callback, _.toArray(arguments));\n        } catch (e) {\n          debug(e);\n          console.log(e.stack);\n          process.emit('uncaughtException', e);\n        }\n      }\n      return;\n    }\n\n    async.each(eventsToDispatch, function (evt, callback) {\n      function setEventToDispatched (e, clb) {\n        if (!e.payload || !e.id || e.disablePersistence) {\n          evts.push(e.payload || e);\n          return callback(null);\n        }\n        debug('set event to dispatched');\n        self.eventStore.setEventToDispatched(e, function (err) {\n          if (err) {\n            return callback(err);\n          }\n          evts.push(e.payload);\n          clb(null);\n        });\n      }\n\n      if (self.onEventHandle) {\n        debug('publish an event');\n        if (evt.payload && evt.id) {\n          self.onEventHandle(evt.payload, function (err) {\n            if (err) {\n              debug(err);\n              return callback(err);\n            }\n            setEventToDispatched(evt, function (err) {\n              if (err) {\n                return callback(err);\n              }\n              callback(null);\n            });\n          });\n        } else {\n          // seams that custom command handler has done some strange stuff!!!\n          self.onEventHandle(evt, function (err) {\n            if (err) {\n              debug(err);\n              return callback(err);\n            }\n            evts.push(evt);\n            callback(null);\n          });\n        }\n      } else {\n        setEventToDispatched(evt, callback);\n      }\n    }, function (err) {\n      if (err) {\n        debug(err);\n      }\n\n      if (callback) {\n        try {\n          callback(err, evts, aggregateData, meta);\n        } catch (e) {\n          debug(e);\n          console.log(e.stack);\n          process.emit('uncaughtException', e);\n        }\n      }\n    });\n  },\n\n  /**\n   * Call this function to let the domain handle it.\n   * @param {Object}   cmd      the command object\n   * @param {Function} callback the function that will be called when this action has finished [optional]\n   *                            `function(err, evts, aggregateData, meta){}` evts is of type Array, aggregateData and meta are an object\n   */\n  handle: function (cmd, callback) {\n    if (!cmd || !_.isObject(cmd) || !dotty.exists(cmd, this.definitions.command.name)) {\n      var err = new Error('Please pass a valid command!');\n      debug(err);\n      if (callback) callback(err);\n      return;\n    }\n\n    var self = this;\n    process.nextTick(function () {\n      if (callback && callback.length > 2) {\n        self.commandDispatcher.dispatch(cmd, function (err, eventsToDispatch, aggregateData, meta) {\n          self.onDispatched(cmd, err, eventsToDispatch, aggregateData, meta, callback);\n        });\n        return;\n      }\n      self.commandDispatcher.dispatch(cmd, function (err, eventsToDispatch) {\n        self.onDispatched(cmd, err, eventsToDispatch, null, null, callback);\n      });\n    });\n  }\n\n});\n\nmodule.exports = Domain;\n","/home/travis/build/npmtest/node-npmtest-cqrs-domain/node_modules/cqrs-domain/lib/lock/index.js":"'use strict';\n\nvar tolerate = require('tolerance'),\n  _ = require('lodash'),\n  Base = require('./base');\n\nfunction getSpecificDbImplementation(options) {\n  options = options || {};\n\n  options.type = options.type || 'inmemory';\n\n  if (_.isFunction(options.type)) {\n    return options.type;\n  }\n\n  options.type = options.type.toLowerCase();\n\n  var dbPath = __dirname + \"/databases/\" + options.type + \".js\";\n\n  var exists = require('fs').existsSync || require('path').existsSync;\n  if (!exists(dbPath)) {\n    var errMsg = 'Implementation for db \"' + options.type + '\" does not exist!';\n    console.log(errMsg);\n    throw new Error(errMsg);\n  }\n\n  try {\n    var db = require(dbPath);\n    return db;\n  } catch (err) {\n\n    if (err.message.indexOf('Cannot find module') >= 0 &&\n      err.message.indexOf(\"'\") > 0 &&\n      err.message.lastIndexOf(\"'\") !== err.message.indexOf(\"'\")) {\n\n      var moduleName = err.message.substring(err.message.indexOf(\"'\") + 1, err.message.lastIndexOf(\"'\"));\n      console.log('Please install module \"' + moduleName +\n        '\" to work with db implementation \"' + options.type + '\"!');\n    }\n\n    throw err;\n  }\n}\n\nmodule.exports = {\n  Lock: Base,\n\n  create: function(options, callback) {\n    if (typeof options === 'function') {\n      callback = options;\n      options = {};\n    }\n\n    options = options || {};\n\n    var Lock;\n\n    try {\n      Lock = getSpecificDbImplementation(options);\n    } catch (err) {\n      if (callback) callback(err);\n      throw err;\n    }\n\n    var lock = new Lock(options);\n    if (callback) {\n      process.nextTick(function () {\n        tolerate(function (callback) {\n          lock.connect(callback);\n        }, options.timeout || 0, callback || function () {\n        });\n      });\n    }\n    return lock;\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-cqrs-domain/node_modules/cqrs-domain/lib/lock/base.js":"'use strict';\n\nvar util = require('util'),\n  EventEmitter = require('events').EventEmitter,\n  prequire = require('parent-require'),\n  _ = require('lodash'),\n  uuid = require('uuid').v4;\n\n/**\n * Lock constructor\n * @param {Object} options The options can have information like host, port, etc. [optional]\n */\nfunction Lock(options) {\n  options = options || {};\n\n  EventEmitter.call(this);\n}\n\nutil.inherits(Lock, EventEmitter);\n\nfunction implementError (callback) {\n  var err = new Error('Please implement this function!');\n  if (callback) callback(err);\n  throw err;\n}\n\n_.extend(Lock.prototype, {\n\n  /**\n   * Initiate communication with the lock.\n   * @param  {Function} callback The function, that will be called when this action is completed. [optional]\n   *                             `function(err, queue){}`\n   */\n  connect: implementError,\n\n  /**\n   * Terminate communication with the lock.\n   * @param  {Function} callback The function, that will be called when this action is completed. [optional]\n   *                             `function(err){}`\n   */\n  disconnect: implementError,\n\n  /**\n   * Use this function to obtain a new id.\n   * @param  {Function} callback The function, that will be called when this action is completed.\n   *                             `function(err, id){}` id is of type String.\n   */\n  getNewId: function (callback) {\n    var id = uuid().toString();\n    if (callback) callback(null, id);\n  },\n\n  /**\n   * Use this function to reserve an aggregate.\n   * @param  {String}   workerId    The id of the worker.\n   * @param  {String}   aggregateId The id of the aggregate\n   * @param  {Function} callback    The function, that will be called when this action is completed. [optional]\n   *                                `function(err){}`\n   */\n  reserve: function (workerId, aggregateId, callback) {\n    implementError(callback);\n  },\n\n  /**\n   * Use this function to get get all the worker that reserve an aggregate.\n   * @param  {String}   aggregateId The id of the aggregate\n   * @param  {Function} callback    The function, that will be called when this action is completed.\n   *                                `function(err, workerIds){}` workerIds is of type Array.\n   */\n  getAll: function (aggregateId, callback) {\n    implementError(callback);\n  },\n\n  /**\n   * Use this function to remove all reservation of an aggregate.\n   * @param  {String}   aggregateId The id of the aggregate\n   * @param  {Function} callback    The function, that will be called when this action is completed. [optional]\n   *                                `function(err){}`\n   */\n  resolve: function (aggregateId, callback) {\n    implementError(callback);\n  },\n\n  /**\n   * NEVER USE THIS FUNCTION!!! ONLY FOR TESTS!\n   * clears the complete store...\n   * @param {Function} callback the function that will be called when this action has finished [optional]\n   */\n  clear: function (callback) {\n    implementError(callback);\n  }\n\n});\n\nLock.use = function (toRequire) {\n  var required;\n  try {\n    required = require(toRequire);\n  } catch (e) {\n    // workaround when `npm link`'ed for development\n    required = prequire(toRequire);\n  }\n  return required;\n};\n\nmodule.exports = Lock;\n","/home/travis/build/npmtest/node-npmtest-cqrs-domain/node_modules/cqrs-domain/lib/bumper/index.js":"'use strict';\n\nvar tolerate = require('tolerance'),\n  _ = require('lodash'),\n  Base = require('./base');\n\nfunction getSpecificDbImplementation(options) {\n  options = options || {};\n\n  options.type = options.type || 'inmemory';\n\n  if (_.isFunction(options.type)) {\n    return options.type;\n  }\n\n  options.type = options.type.toLowerCase();\n\n  var dbPath = __dirname + \"/databases/\" + options.type + \".js\";\n\n  var exists = require('fs').existsSync || require('path').existsSync;\n  if (!exists(dbPath)) {\n    var errMsg = 'Implementation for db \"' + options.type + '\" does not exist!';\n    console.log(errMsg);\n    throw new Error(errMsg);\n  }\n\n  try {\n    var db = require(dbPath);\n    return db;\n  } catch (err) {\n\n    if (err.message.indexOf('Cannot find module') >= 0 &&\n      err.message.indexOf(\"'\") > 0 &&\n      err.message.lastIndexOf(\"'\") !== err.message.indexOf(\"'\")) {\n\n      var moduleName = err.message.substring(err.message.indexOf(\"'\") + 1, err.message.lastIndexOf(\"'\"));\n      console.log('Please install module \"' + moduleName +\n        '\" to work with db implementation \"' + options.type + '\"!');\n    }\n\n    throw err;\n  }\n}\n\nmodule.exports = {\n  Bumper: Base,\n\n  create: function(options, callback) {\n    if (typeof options === 'function') {\n      callback = options;\n      options = {};\n    }\n\n    options = options || {};\n\n    var Bumper;\n\n    try {\n      Bumper = getSpecificDbImplementation(options);\n    } catch (err) {\n      if (callback) callback(err);\n      throw err;\n    }\n\n    var bumper = new Bumper(options);\n    if (callback) {\n      process.nextTick(function () {\n        tolerate(function (callback) {\n          bumper.connect(callback);\n        }, options.timeout || 0, callback || function () {\n        });\n      });\n    }\n    return bumper;\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-cqrs-domain/node_modules/cqrs-domain/lib/bumper/base.js":"'use strict';\n\nvar util = require('util'),\n  EventEmitter = require('events').EventEmitter,\n  prequire = require('parent-require'),\n  _ = require('lodash'),\n  uuid = require('uuid').v4;\n\n/**\n * Bumper constructor\n * @param {Object} options The options can have information like host, port, etc. [optional]\n */\nfunction Bumper(options) {\n  options = options || {};\n\n  EventEmitter.call(this);\n}\n\nutil.inherits(Bumper, EventEmitter);\n\nfunction implementError (callback) {\n  var err = new Error('Please implement this function!');\n  if (callback) callback(err);\n  throw err;\n}\n\n_.extend(Bumper.prototype, {\n\n  /**\n   * Initiate communication with the lock.\n   * @param  {Function} callback The function, that will be called when this action is completed. [optional]\n   *                             `function(err, queue){}`\n   */\n  connect: implementError,\n\n  /**\n   * Terminate communication with the lock.\n   * @param  {Function} callback The function, that will be called when this action is completed. [optional]\n   *                             `function(err){}`\n   */\n  disconnect: implementError,\n\n  /**\n   * Use this function to obtain a new id.\n   * @param  {Function} callback The function, that will be called when this action is completed.\n   *                             `function(err, id){}` id is of type String.\n   */\n  getNewId: function (callback) {\n    var id = uuid().toString();\n    if (callback) callback(null, id);\n  },\n\n  /**\n   * Use this function to add a key with expiration.\n   * @param  {String}   key      The key\n   * @param  {Number}   ttl      The time to live in ms\n   * @param  {Function} callback The function, that will be called when this action is completed. [optional]\n   *                             `function(err, added){}`\n   */\n  add: function (key, ttl, callback) {\n    implementError(callback);\n  },\n\n  /**\n   * NEVER USE THIS FUNCTION!!! ONLY FOR TESTS!\n   * clears the complete store...\n   * @param {Function} callback the function that will be called when this action has finished [optional]\n   */\n  clear: function (callback) {\n    implementError(callback);\n  }\n\n});\n\nBumper.use = function (toRequire) {\n  var required;\n  try {\n    required = require(toRequire);\n  } catch (e) {\n    // workaround when `npm link`'ed for development\n    required = prequire(toRequire);\n  }\n  return required;\n};\n\nmodule.exports = Bumper;\n","/home/travis/build/npmtest/node-npmtest-cqrs-domain/node_modules/cqrs-domain/lib/structure/structureLoader.js":"'use strict';\n\nvar debug = require('debug')('domain:structureLoader'),\n  _ = require('lodash'),\n  path = require('path'),\n  structureParser = require('./structureParser'),\n  Context = require('./../definitions/context'),\n  Aggregate = require('./../definitions/aggregate'),\n  Command = require('./../definitions/command'),\n  Event = require('./../definitions/event'),\n  BusinessRule = require('./../definitions/businessRule'),\n  PreCondition = require('./../definitions/preCondition'),\n  PreLoadCondition = require('./../definitions/preLoadCondition'),\n  CommandHandler = require('./../definitions/commandHandler');\n\nfunction isSchema (item) {\n  return item.fileType === 'json' && item.value.title;\n}\n\nfunction isContext (item) {\n  if (item.fileType !== 'js') {\n    return false;\n  }\n\n  return item.value instanceof Context;\n}\n\nfunction isAggregate (item) {\n  if (item.fileType !== 'js') {\n    return false;\n  }\n\n  return item.value instanceof Aggregate;\n}\n\nfunction isCommand (item) {\n  if (item.fileType !== 'js') {\n    return false;\n  }\n\n  return item.value instanceof Command;\n}\n\nfunction isEvent (item) {\n  if (item.fileType !== 'js') {\n    return false;\n  }\n\n  return item.value instanceof Event;\n}\n\nfunction isPreCondition (item) {\n  if (item.fileType !== 'js') {\n    return false;\n  }\n\n  return item.value instanceof PreCondition;\n}\n\nfunction isPreLoadCondition (item) {\n  if (item.fileType !== 'js') {\n    return false;\n  }\n\n  return item.value instanceof PreLoadCondition;\n}\n\nfunction isBusinessRule (item) {\n  if (item.fileType !== 'js') {\n    return false;\n  }\n\n  return item.value instanceof BusinessRule;\n}\n\nfunction isCommandHandler (item) {\n  if (item.fileType !== 'js') {\n    return false;\n  }\n\n  return item.value instanceof CommandHandler;\n}\n\nfunction defineNameOfSchema (item) {\n  var name = item.value.title;\n  if (!name) {\n    var splits = item.dottiedBase.split('.');\n    name = splits[splits.length - 1];\n  }\n  item.name = name;\n}\n\nfunction defineName (item, invert) {\n  var name = item.value.name;\n\n  if (name === '') {\n    item.name = name;\n    return;\n  }\n\n  function defineNameByDir () {\n    if (!name) {\n      var splits = item.dottiedBase.split('.');\n      name = splits[splits.length - 1];\n    }\n\n    if (!name) {\n      var tmp = item.path.substring(0, item.path.lastIndexOf(path.sep + item.fileName));\n      name = tmp.substring(tmp.lastIndexOf(path.sep) + 1);\n    }\n  }\n\n  function defineNameByFileName () {\n    if (!name) {\n      name = item.fileName.substring(0, item.fileName.lastIndexOf('.'));\n    }\n  }\n\n  if (invert) {\n    defineNameByDir();\n    defineNameByFileName();\n  } else {\n    defineNameByFileName();\n    defineNameByDir();\n  }\n\n  item.name = name;\n}\n\nfunction scan (items) {\n  var res = {\n    schemas: [],\n    contexts: [],\n    aggregates: [],\n    commands: [],\n    events: [],\n    preConditions: [],\n    preLoadConditions: [],\n    businessRules: [],\n    commandHandlers: []\n  };\n\n  items.forEach(function (item) {\n    if (isSchema(item)) {\n      debug('found schema at: ' + item.path);\n      defineNameOfSchema(item);\n      res.schemas.push(item);\n      return;\n    }\n\n    if (isContext(item)) {\n      debug('found context at: ' + item.path);\n      defineName(item, true);\n      item.value.name = item.name;\n      res.contexts.push(item);\n      return;\n    }\n\n    if (isAggregate(item)) {\n      debug('found aggregate at: ' + item.path);\n      defineName(item, true);\n      item.value.name = item.name;\n      res.aggregates.push(item);\n      return;\n    }\n\n    if (isCommand(item)) {\n      debug('found command at: ' + item.path);\n      defineName(item);\n      item.value.name = item.name;\n      res.commands.push(item);\n      return;\n    }\n\n    if (isEvent(item)) {\n      debug('found event at: ' + item.path);\n      defineName(item);\n      item.value.name = item.name;\n      res.events.push(item);\n      return;\n    }\n\n    if (isBusinessRule(item)) {\n      debug('found businessRule at: ' + item.path);\n      defineName(item);\n      item.value.name = item.name;\n      res.businessRules.push(item);\n      return;\n    }\n\n\n\n    if (isPreCondition(item)) {\n      debug('found preCondition at: ' + item.path);\n      defineName(item);\n      if (!_.isArray(item.name)) {\n        item.name = [item.name];\n      }\n      item.value.name = item.name;\n      res.preConditions.push(item);\n      return;\n    }\n\n    if (isCommandHandler(item)) {\n      debug('found commandHandler at: ' + item.path);\n      defineName(item);\n      item.value.name = item.name;\n      res.commandHandlers.push(item);\n      return;\n    }\n\n    if (isPreLoadCondition(item)) {\n      debug('found preLoadCondition at: ' + item.path);\n      defineName(item);\n      if (!_.isArray(item.name)) {\n        item.name = [item.name];\n      }\n      item.value.name = item.name;\n      res.preLoadConditions.push(item);\n      return;\n    }\n  });\n\n\n\n  return res;\n}\n\nfunction analyze (dir, callback) {\n  structureParser(dir, function (items) {\n    return _.filter(items, function (i) {\n      return isSchema(i) || isContext(i) || isAggregate(i) || isCommand(i) || isEvent(i) || isBusinessRule(i) || isPreCondition(i) || isPreLoadCondition(i) || isCommandHandler(i);\n    });\n  }, function (err, items, warns) {\n    if (err) {\n      return callback(err);\n    }\n\n    var res = scan(items);\n\n    callback(null, res, warns);\n  });\n}\n\nfunction reorderAggregates (obj, ordered) {\n  var generalContext = new Context({ name: '_general' });\n\n  obj.aggregates.forEach(function (aggItem) {\n    var foundCtx = _.find(obj.contexts, function (ctx) {\n      if (aggItem.dottiedBase.indexOf('.') >= 0) {\n        return aggItem.dottiedBase.indexOf(ctx.dottiedBase + '.') === 0;\n      } else {\n        return aggItem.dottiedBase === ctx.dottiedBase;\n      }\n    });\n\n    if (!foundCtx) {\n      foundCtx = _.find(obj.contexts, function (ctx) {\n        return ctx.dottiedBase === '';\n      });\n    }\n\n    var ctxName = '_general';\n    if (foundCtx) {\n      ctxName = foundCtx.name;\n      ordered[ctxName] = ordered[ctxName] || foundCtx.value;\n    } else {\n      ordered[ctxName] = ordered[ctxName] || generalContext;\n    }\n    ordered[ctxName].addAggregate(aggItem.value);\n\n    // mark context for aggregate\n    aggItem.context = ctxName;\n  });\n}\n\nfunction reorderDefault (obj, ordered, what) {\n  obj[what + 's'].forEach(function (objItem) {\n    var foundAggr = _.find(obj.aggregates, function (aggr) {\n      if (objItem.dottiedBase.indexOf('.') >= 0) {\n        return objItem.dottiedBase.indexOf(aggr.dottiedBase + '.') === 0;\n      } else {\n        return objItem.dottiedBase === aggr.dottiedBase;\n      }\n    });\n\n    if (!foundAggr) {\n      return;\n    }\n\n    var whatCap = what.charAt(0).toUpperCase() + what.slice(1);\n\n    var agg = ordered[foundAggr.context].getAggregate(foundAggr.name);\n\n    agg['add' + whatCap].call(agg, objItem.value);\n\n    // mark context and aggregate\n    objItem.context = foundAggr.context;\n    objItem.aggregate = foundAggr.name;\n  });\n}\n\nfunction reorderCommands (obj, ordered) {\n  reorderDefault(obj, ordered, 'command');\n}\n\nfunction reorderEvents (obj, ordered) {\n  reorderDefault(obj, ordered, 'event');\n}\n\nfunction reorderBusinessRules (obj, ordered) {\n  reorderDefault(obj, ordered, 'businessRule');\n}\n\nfunction reorderCommandHandlers (obj, ordered) {\n  reorderDefault(obj, ordered, 'commandHandler');\n}\n\nfunction preorderPreConditions (obj, ordered) {\n  obj.preConditions.forEach(function (objItem) {\n    var foundAggr = _.find(obj.aggregates, function (aggr) {\n      if (objItem.dottiedBase.indexOf('.') >= 0) {\n        return objItem.dottiedBase.indexOf(aggr.dottiedBase + '.') === 0;\n      } else {\n        return objItem.dottiedBase === aggr.dottiedBase;\n      }\n    });\n\n    if (!foundAggr) {\n      return;\n    }\n\n    // mark context and aggregate\n    objItem.context = foundAggr.context;\n    objItem.aggregate = foundAggr.name;\n  });\n}\n\nfunction reorderPreConditions (obj, ordered) {\n  preorderPreConditions(obj, ordered);\n\n  obj.preConditions.forEach(function (pc) {\n\n    var foundCmds = _.filter(obj.commands, function (cmd) {\n      return pc.context === cmd.context &&\n             pc.aggregate === cmd.aggregate &&\n            (pc.name.indexOf(cmd.name) >= 0 || pc.name.indexOf('') >= 0) &&\n            (pc.name.indexOf('') >= 0 || pc.version === cmd.version);\n    });\n\n    if (!foundCmds || foundCmds.length === 0) {\n      if (pc.name.length > 0) {\n        debug('no cmd found for ',  pc.name);\n        return;\n      }\n      return;\n    }\n\n    foundCmds.forEach(function (foundCmd) {\n      foundCmd.value.addPreCondition(pc.value);\n    });\n  });\n}\n\nfunction preorderPreLoadConditions (obj, ordered) {\n  obj.preLoadConditions.forEach(function (objItem) {\n    var foundAggr = _.find(obj.aggregates, function (aggr) {\n      if (objItem.dottiedBase.indexOf('.') >= 0) {\n        return objItem.dottiedBase.indexOf(aggr.dottiedBase + '.') === 0;\n      } else {\n        return objItem.dottiedBase === aggr.dottiedBase;\n      }\n    });\n\n    if (!foundAggr) {\n      return;\n    }\n\n    // mark context and aggregate\n    objItem.context = foundAggr.context;\n    objItem.aggregate = foundAggr.name;\n  });\n}\n\nfunction reorderPreLoadConditions (obj, ordered) {\n  preorderPreLoadConditions(obj, ordered);\n\n  obj.preLoadConditions.forEach(function (plc) {\n\n    var foundCmds = _.filter(obj.commands, function (cmd) {\n      return plc.context === cmd.context &&\n        plc.aggregate === cmd.aggregate &&\n        (plc.name.indexOf(cmd.name) >= 0 || plc.name.indexOf('') >= 0) &&\n        (plc.name.indexOf('') >= 0 || plc.version === cmd.version);\n    });\n\n    if (!foundCmds || foundCmds.length === 0) {\n      if (plc.name.length > 0) {\n        debug('no cmd found for ',  plc.name);\n        return;\n      }\n      return;\n    }\n\n    foundCmds.forEach(function (foundCmd) {\n      foundCmd.value.addPreLoadCondition(plc.value);\n    });\n  });\n}\n\nfunction reorderValidationRules (obj, ordered, validatorExtension) {\n  var allSchemas = {};\n  var cmdSchemas = [];\n\n  obj.schemas.forEach(function (schemaItem) {\n\n    allSchemas['/' + schemaItem.name] = schemaItem.value;\n\n    var foundCtx = _.find(obj.contexts, function (ctx) {\n      return schemaItem.dottiedBase.indexOf(ctx.dottiedBase) === 0;\n    });\n    if (foundCtx) {\n      schemaItem.context = foundCtx.name;\n    } else {\n      schemaItem.context = '_general';\n    }\n\n    var foundAggr = _.find(obj.aggregates, function (aggr) {\n      return schemaItem.dottiedBase.indexOf(aggr.dottiedBase) === 0;\n    });\n\n    if (foundAggr) {\n      schemaItem.aggregate = foundAggr.name;\n    }\n\n    if (!schemaItem.context || (schemaItem.context === '_general' && schemaItem.dottiedBase === '' && !schemaItem.aggregate)) {\n      // it's a general schema\n      return;\n    }\n\n    if (foundCtx && foundCtx.dottiedBase === schemaItem.dottiedBase && schemaItem.context !== '_general') {\n      // it's a context schema\n      return;\n    }\n\n    if (!schemaItem.aggregate) {\n      debug('no aggregate found for schema: ' + schemaItem.path);\n      // skip\n      return;\n    }\n\n    if (foundAggr.dottiedBase === schemaItem.dottiedBase) {\n      var foundPossibleCommand = _.find(foundAggr.value.commands, 'name', schemaItem.value.title);\n      if (!foundPossibleCommand) {\n        // it's an aggregate schema\n        return;\n      }\n    }\n\n    cmdSchemas.push(schemaItem);\n  });\n\n  var formats = {};\n\n  var getValidatorFn = require('./../validator');\n\n  var validator = {\n    addFormat: function (key, value) {\n      if (!key) {\n        var err = new Error('Please pass valid arguments!');\n        debug(err);\n        throw err;\n      }\n\n      if (!value) {\n        _.forOwn(key, function (v, k) {\n          formats[k] = v;\n        });\n      } else {\n        formats[key] = value;\n      }\n    },\n    addSchema: function (key, value) {\n      if (!key) {\n        var err = new Error('Please pass valid arguments!');\n        debug(err);\n        throw err;\n      }\n\n      if (!value) {\n        _.forOwn(key, function (v, k) {\n          allSchemas[k] = v;\n        });\n      } else {\n        allSchemas[key] = value;\n      }\n    },\n    validator: function (fn) {\n      if (!fn || _.isFunction(fn)) {\n        var err = new Error('Please pass a valid function!');\n        debug(err);\n        throw err;\n      }\n\n      getValidatorFn = fn;\n    }\n  };\n\n  validatorExtension(validator);\n\n  cmdSchemas.forEach(function (schemaItem) {\n    // check for all commands, if nothing found continue...\n    obj.commands.forEach(function (cmdItem) {\n      if (cmdItem.name === schemaItem.name &&\n        cmdItem.aggregate === schemaItem.aggregate &&\n        cmdItem.context === schemaItem.context &&\n        ((schemaItem.value.version === undefined || schemaItem.value.version === null) || cmdItem.value.version === schemaItem.value.version)) {\n        var cmd = ordered[schemaItem.context].getAggregate(schemaItem.aggregate).getCommand(schemaItem.name, schemaItem.value.version);\n        // it's a command schema\n        cmd.defineValidation(getValidatorFn({ schemas: allSchemas, formats: formats }, schemaItem.value));\n      }\n    });\n  });\n}\n\nfunction reorder (obj, validatorExtension) {\n  var ordered = {};\n\n  reorderAggregates(obj, ordered);\n\n  reorderCommands(obj, ordered);\n\n  reorderEvents(obj, ordered);\n\n  reorderBusinessRules(obj, ordered);\n\n  reorderCommandHandlers(obj, ordered);\n\n  reorderValidationRules(obj, ordered, validatorExtension);\n\n  reorderPreLoadConditions(obj, ordered);\n\n  reorderPreConditions(obj, ordered);\n\n  if (!ordered || _.isEmpty(ordered)) {\n    debug('analyzed: ', obj);\n    debug('ordered: ', ordered);\n  }\n\n  return ordered;\n}\n\nfunction load (dir, validatorExtension, callback) {\n  analyze(dir, function (err, dividedByTypes, warns) {\n    if (err) {\n      return callback(err);\n    }\n\n    var structured = reorder(dividedByTypes, validatorExtension);\n\n    callback(err, structured, warns);\n  });\n}\n\nmodule.exports = load;\n","/home/travis/build/npmtest/node-npmtest-cqrs-domain/node_modules/cqrs-domain/lib/structure/structureParser.js":"'use strict';\n\nvar debug = require('debug')('domain:structureParser'),\n  _ = require('lodash'),\n  fs = require('fs'),\n  path = require('path');\n\nvar validFileTypes = ['js', 'json'];\n\nfunction isValidFileType(fileName) {\n  var index = fileName.lastIndexOf('.');\n  if (index < 0) {\n    return false;\n  }\n  var fileType = fileName.substring(index + 1);\n  var index = validFileTypes.indexOf(fileType);\n  if (index < 0) {\n    return false;\n  }\n  return validFileTypes[index];\n}\n\nfunction loadPaths (dir, callback) {\n  dir = path.resolve(dir);\n\n  var results = [];\n  fs.readdir(dir, function (err, list) {\n    if (err) {\n      debug(err);\n      return callback(err);\n    }\n\n    var pending = list.length;\n\n    if (pending === 0) return callback(null, results);\n\n    list.forEach(function (file) {\n      var pathFull = path.join(dir, file);\n      fs.stat(pathFull, function(err, stat) {\n        if (err) {\n          return debug(err);\n        }\n\n        // if directory, go deep...\n        if (stat && stat.isDirectory()) {\n          loadPaths(pathFull, function (err, res) {\n            results = results.concat(res);\n            if (!--pending) callback(null, results);\n          });\n          return;\n        }\n\n        // if a file we are looking for\n        if (isValidFileType(pathFull)) {\n          results.push(pathFull);\n        }\n\n        // of just an other file, skip...\n        if (!--pending) callback(null, results);\n      });\n    });\n  });\n}\n\nfunction pathToJson (root, paths, addWarning) {\n  root = path.resolve(root);\n  var res = [];\n\n  paths.forEach(function (p) {\n    if (p.indexOf(root) >= 0) {\n      var part = p.substring(root.length);\n      if (part.indexOf(path.sep) === 0) {\n        part = part.substring(path.sep.length);\n      }\n\n      var splits = part.split(path.sep);\n      var withoutFileName = splits;\n      withoutFileName.splice(splits.length - 1);\n      var fileName = path.basename(part);\n\n      var dottiedBase = '';\n      withoutFileName.forEach(function (s, i) {\n        if (i + 1 < withoutFileName.length) {\n          dottiedBase += s + '.';\n        } else {\n          dottiedBase += s;\n        }\n      });\n\n      try {\n        var required = require(p);\n\n//        // clean cache, fixes multiple loading of same aggregates, commands, etc...\n//        if (require.cache[require.resolve(p)]) {\n//          delete require.cache[require.resolve(p)];\n//        }\n\n        if (!required || _.isEmpty(required)) {\n          return;\n        }\n\n        if (_.isArray(required)) {\n          _.each(required, function (req) {\n            res.push({\n              path: p,\n              dottiedBase: dottiedBase,\n              fileName: fileName,\n              value: req,\n              fileType: path.extname(p).substring(1)\n            });\n          });\n        } else {\n          res.push({\n            path: p,\n            dottiedBase: dottiedBase,\n            fileName: fileName,\n            value: required,\n            fileType: path.extname(p).substring(1)\n          });\n        }\n      } catch (err) {\n        debug(err);\n        if (addWarning) {\n          addWarning(err);\n        }\n      }\n    } else {\n      debug('path is not a subpath from root');\n    }\n  });\n\n  return res;\n}\n\nfunction parse (dir, filter, callback) {\n  if (!callback) {\n    callback = filter;\n    filter = function (r) {\n      return r;\n    };\n  }\n\n  dir = path.resolve(dir);\n  loadPaths(dir, function (err, paths) {\n    if (err) {\n      return callback(err);\n    }\n\n    var warns = [];\n    function addWarning (e) {\n      warns.push(e);\n    }\n\n    var res = filter(pathToJson(dir, paths, addWarning));\n\n    var dottiesParts = [];\n\n    res.forEach(function (r) {\n      var parts = r.dottiedBase.split('.');\n      parts.forEach(function (p, i) {\n        if (!dottiesParts[i]) {\n          return dottiesParts[i] = [p];\n        }\n\n        if (dottiesParts[i].indexOf(p) < 0) {\n          dottiesParts[i].push(p);\n        }\n      });\n    });\n\n    var toRemove = '';\n\n    for (var pi = 0, plen = dottiesParts.length; pi < plen; pi++) {\n      if (dottiesParts[pi].length === 1) {\n        toRemove += dottiesParts[pi][0];\n      } else {\n        break;\n      }\n    }\n\n    if (toRemove.length > 0) {\n      res.forEach(function (r) {\n        if (r.dottiedBase === toRemove) {\n          r.dottiedBase = '';\n        } else {\n          r.dottiedBase = r.dottiedBase.substring(toRemove.length + 1);\n        }\n      });\n    }\n\n    if (warns.length === 0) {\n      warns = null;\n    }\n\n    callback(null, res, warns);\n  });\n}\n\nmodule.exports = parse;\n","/home/travis/build/npmtest/node-npmtest-cqrs-domain/node_modules/cqrs-domain/lib/definitions/context.js":"'use strict';\n\nvar Definition = require('../definitionBase'),\n  util = require('util'),\n  _ = require('lodash'),\n  debug = require('debug')('domain:context'),\n  Aggregate = require('./aggregate');\n\n/**\n * Context constructor\n * @param {Object} meta meta infos like: { name: 'name' }\n * @constructor\n */\nfunction Context (meta) {\n  Definition.call(this, meta);\n\n  meta = meta || {};\n\n  this.aggregates = [];\n}\n\nutil.inherits(Context, Definition);\n\n_.extend(Context.prototype, {\n\n  /**\n   * Adds an aggregate to this context.\n   * @param {Aggregate} aggregate the aggregate that should be added\n   */\n  addAggregate: function (aggregate) {\n    if (!aggregate || !(aggregate instanceof Aggregate)) {\n      throw new Error('Passed object should be an Aggregate');\n    }\n\n    aggregate.defineContext(this);\n\n    if (this.aggregates.indexOf(aggregate) < 0) {\n      this.aggregates.push(aggregate);\n    }\n  },\n\n  /**\n   * Returns the aggregate with the requested name.\n   * @param {String} name command name\n   * @returns {Aggregate}\n   */\n  getAggregate: function (name) {\n    if (!name || !_.isString(name)) {\n      throw new Error('Please pass in an aggregate name!');\n    }\n\n    return _.find(this.aggregates, function (agg) {\n      return agg.name === name;\n    });\n  },\n\n  /**\n   * Return the aggregate that handles the requested command.\n   * @param {String} name    command name\n   * @param {Number} version command version\n   * @returns {Aggregate}\n   */\n  getAggregateForCommand: function (name, version) {\n    if (!name || !_.isString(name)) {\n      throw new Error('Please pass in a command name!');\n    }\n\n    for (var a in this.aggregates) {\n      var aggr = this.aggregates[a];\n      var cmd = aggr.getCommand(name, version);\n      if (cmd) {\n        return aggr;\n      }\n    }\n\n    for (var a in this.aggregates) {\n      var aggr = this.aggregates[a];\n      var cmdHndl = aggr.getCommandHandler(name, version);\n      if (cmdHndl && cmdHndl !== aggr.defaultCommandHandler) {\n        return aggr;\n      }\n    }\n\n    debug('no matching aggregate found for command ' + name);\n\n    return null;\n  },\n\n  // /**\n  //  * Return the aggregate that handles the requested command.\n  //  * @param {Object} query the query object\n  //  * @returns {Aggregate}\n  //  */\n  // getAggregateForCommandByOldTarget: function (query) {\n  //   if (!query) {\n  //     throw new Error('Please pass in a query object!');\n  //   }\n  //\n  //   for (var a in this.aggregates) {\n  //     var aggr = this.aggregates[a];\n  //     var cmd = aggr.getCommand(query.name, query.version);\n  //     if (cmd && cmd.source && cmd.source.context === query.context && cmd.source.aggregate === query.aggregate) {\n  //       return aggr;\n  //     }\n  //   }\n  //\n  //   for (var a in this.aggregates) {\n  //     var aggr = this.aggregates[a];\n  //     var cmdHndl = aggr.getCommandHandler(query.name, query.version);\n  //     if (cmdHndl && cmdHndl !== aggr.defaultCommandHandler && cmdHndl.source && cmdHndl.source.context === query.context && cmdHndl.source.aggregate === query.aggregate) {\n  //       return aggr;\n  //     }\n  //   }\n  //\n  //   debug('no matching aggregate found for command ' + query.name);\n  //\n  //   return null;\n  // },\n\n  /**\n   * Return all aggregates.\n   * @returns {Array}\n   */\n  getAggregates: function () {\n    return this.aggregates;\n  }\n\n});\n\nmodule.exports = Context;\n","/home/travis/build/npmtest/node-npmtest-cqrs-domain/node_modules/cqrs-domain/lib/definitionBase.js":"'use strict';\n\nvar _ = require('lodash');\n\n/**\n * Definition constructor\n * @param {Object} meta meta infos like: { name: 'name' }\n * @constructor\n */\nfunction Definition (meta) {\n  if (!this.name && meta) {\n    this.name = meta.name;\n  }\n\n  this.options = {};\n\n  this.definitions = {\n    command: {\n      id: 'id',\n      name: 'name',\n      aggregateId: 'aggregate.id'\n//      context: 'context.name',        // optional\n//      aggregate: 'aggregate.name',    // optional\n//      payload: 'payload',             // optional\n//      revision: 'revision',           // optional\n//      version: 'version',             // optional\n//      meta: 'meta'                    // optional (will be passed directly to corresponding event(s))\n    },\n    event: {\n      correlationId: 'correlationId',\n      id: 'id',\n      name: 'name',\n      aggregateId: 'aggregate.id',\n//      context: 'context.name',        // optional\n//      aggregate: 'aggregate.name',    // optional\n      payload: 'payload',               // optional\n      revision: 'revision'              // optional\n//      version: 'version',             // optional\n//      meta: 'meta'                    // optional (will be passed directly from corresponding command)\n    }\n  };\n}\n\n/**\n * Inject definition for command structure.\n * @param   {Object} definition the definition to be injected\n */\nDefinition.prototype.defineCommand = function (definition) {\n  if (!_.isObject(definition)) {\n    throw new Error('Please pass in an object');\n  }\n  this.definitions.command = _.defaults(definition, this.definitions.command);\n};\n\n/**\n * Inject definition for event structure.\n * @param   {Object} definition the definition to be injected\n */\nDefinition.prototype.defineEvent = function (definition) {\n  if (!_.isObject(definition)) {\n    throw new Error('Please pass in an object');\n  }\n  this.definitions.event = _.defaults(definition, this.definitions.event);\n  return this;\n};\n\n/**\n * Inject options.\n * @param   {Object} options the options to be injected\n */\nDefinition.prototype.defineOptions = function (options) {\n  if (!_.isObject(options)) {\n    throw new Error('Please pass in an object');\n  }\n  this.options = options;\n  return this;\n};\n\nmodule.exports = Definition;\n","/home/travis/build/npmtest/node-npmtest-cqrs-domain/node_modules/cqrs-domain/lib/definitions/aggregate.js":"'use strict';\n\nvar Definition = require('../definitionBase'),\n  util = require('util'),\n  _ = require('lodash'),\n  debug = require('debug')('domain:aggregate'),\n  AggregateModel = require('../aggregateModel'),\n  dotty = require('dotty'),\n  DefaultCommandHandler = require('../defaultCommandHandler'),\n  uuid = require('uuid').v4,\n  async = require('async');\n\n/**\n * Aggregate constructor\n * @param {Object} meta            Meta infos like: { name: 'name', version: 1 }\n * @param {Object} modelInitValues Initialization values for model like: { emails: [] } [optional]\n * @constructor\n */\nfunction Aggregate (meta, modelInitValues) {\n  Definition.call(this, meta);\n\n  meta = meta || {};\n\n  this.version = meta.version || 0;\n\n  this.defaultCommandPayload = meta.defaultCommandPayload || '';\n  this.defaultEventPayload = meta.defaultEventPayload || '';\n  this.defaultPreConditionPayload = meta.defaultPreConditionPayload || '';\n  this.defaultPreLoadConditionPayload = meta.defaultPreLoadConditionPayload || '';\n  this.skipHistory = meta.skipHistory || false;\n  this.applyLastEvent = meta.applyLastEvent || false;\n  this.disablePersistence = meta.disablePersistence || false;\n\n  this.commands = [];\n  this.events = [];\n  this.businessRules = [];\n  this.commandHandlers = [];\n\n  this.snapshotConversions = {};\n  this.snapshotIgnores = {};\n\n  this.idGenerator(function () {\n    return uuid().toString();\n  });\n\n  this.modelInitValues = modelInitValues || {};\n\n  this.defaultCommandHandler = new DefaultCommandHandler(this);\n  this.defaultCommandHandler.useAggregate(this);\n\n  this.snapshotConversionRegistrations = [];\n}\n\nutil.inherits(Aggregate, Definition);\n\n/**\n * Returns the apply function for the AggregateModel.\n * @param {Aggregate}      aggregate      The aggregate object.\n * @param {AggregateModel} aggregateModel The aggregateModel object.\n * @param {Command}        cmd            The command object that caused this.\n * @returns {Function}\n */\nfunction applyHelper (aggregate, aggregateModel, cmd) {\n  return function (name, payload, version) {\n    aggregateModel.set = function () {\n      AggregateModel.prototype.set.apply(aggregateModel, _.toArray(arguments));\n    };\n\n    var evt;\n\n    if (!payload) {\n      if (_.isString(name)) {\n        evt = {};\n        dotty.put(evt, aggregate.definitions.event.name, name);\n      } else if (_.isObject(name)) {\n        evt = name;\n      }\n    } else {\n      evt = {};\n      dotty.put(evt, aggregate.definitions.event.name, name);\n      dotty.put(evt, aggregate.definitions.event.payload, payload);\n    }\n\n    if (!!aggregate.definitions.event.meta && !!aggregate.definitions.command.meta) {\n      var commandMeta = dotty.get(cmd, aggregate.definitions.command.meta);\n      var userAddedMeta = dotty.get(evt, aggregate.definitions.event.meta);\n      var meta = (commandMeta || userAddedMeta) && _.extend({}, commandMeta, userAddedMeta);\n      dotty.put(evt, aggregate.definitions.event.meta, meta);\n    }\n\n    dotty.put(evt, aggregate.definitions.event.aggregateId, aggregateModel.id);\n    dotty.put(evt, aggregate.definitions.event.correlationId, dotty.get(cmd, aggregate.definitions.command.id));\n\n    if (!!aggregate.definitions.event.version) {\n      if (_.isNumber(version)) {\n        dotty.put(evt, aggregate.definitions.event.version, version);\n      }\n\n      if (!dotty.exists(evt, aggregate.definitions.event.version)) {\n        // if version is not defined in event, search the latest version number...\n        var evtName = dotty.get(evt, aggregate.definitions.event.name);\n        var maxVersion = _.reduce(aggregate.getEvents(), function (res, e) {\n          if (e.name !== evtName) {\n            return res;\n          }\n\n          var v = e.version || 0;\n          if (v > res) {\n            return v;\n          }\n          return res;\n        }, 0);\n        dotty.put(evt, aggregate.definitions.event.version, maxVersion);\n      }\n    }\n\n    var aggName, ctxName;\n\n    if (!!aggregate.definitions.event.aggregate && !!aggregate.definitions.command.aggregate) {\n      aggName = dotty.get(cmd, aggregate.definitions.command.aggregate);\n      dotty.put(evt, aggregate.definitions.event.aggregate, aggName || aggregate.name);\n    }\n\n    if (!!aggregate.definitions.event.context && !!aggregate.definitions.command.context) {\n      ctxName = dotty.get(cmd, aggregate.definitions.command.context);\n      dotty.put(evt, aggregate.definitions.event.context, ctxName || aggregate.context.name);\n    }\n\n    var aggregateId;\n\n    if (!!aggregate.definitions.event.aggregateId) {\n      aggregateId = dotty.get(evt, aggregate.definitions.event.aggregateId);\n    }\n\n    var streamInfo = {\n      context: ctxName,// || aggregate.context.name,\n      aggregate: aggName,// || aggregate.name,\n      aggregateId: aggregateId || aggregateModel.id\n    };\n    var revision = aggregateModel.getRevision(streamInfo) + 1;\n    aggregateModel.setRevision(streamInfo, revision);\n    dotty.put(evt, aggregate.definitions.event.revision, revision);\n\n    aggregateModel.addUncommittedEvent(evt);\n\n    // apply the event\n    debug('apply the event');\n    aggregate.apply(_.cloneDeep(evt), aggregateModel);\n\n    aggregateModel.set = function () {\n      throw new Error('You are not allowed to set a value in this step!');\n    };\n  };\n\n}\n\n_.extend(Aggregate.prototype, {\n\n  /**\n   * Inject idGenerator function.\n   * @param   {Function}  fn The function to be injected.\n   * @returns {Aggregate}    to be able to chain...\n   */\n  idGenerator: function (fn) {\n    if (fn.length === 0) {\n      fn = _.wrap(fn, function(func, callback) {\n        callback(null, func());\n      });\n    }\n\n    this.getNewId = fn;\n\n    return this;\n  },\n\n  /**\n   * Inject the context module.\n   * @param {Context} context The context module to be injected.\n   */\n  defineContext: function (context) {\n    if (!context || !_.isObject(context)) {\n      var err = new Error('Please inject a valid context object!');\n      debug(err);\n      throw err;\n    }\n\n    this.context = context;\n\n    for (var r in this.snapshotConversionRegistrations) {\n      var reg = this.snapshotConversionRegistrations[r];\n      var meta = reg.meta;\n      var fn = reg.fn;\n\n      meta.context = meta.context || this.context.name;\n      meta.aggregate = meta.aggregate || this.name;\n\n      this.snapshotConversions[meta.context + '.' + meta.aggregate + '.' + meta.version] = fn;\n    }\n  },\n\n  /**\n   * Add command module.\n   * @param {Command} command The command module to be injected.\n   */\n  addCommand: function (command) {\n    if (!command || !_.isObject(command)) {\n      var err = new Error('Please inject a valid command object!');\n      debug(err);\n      throw err;\n    }\n\n    if (!command.payload && command.payload !== '') {\n      command.payload = this.defaultCommandPayload;\n    }\n\n    command.defineAggregate(this);\n\n    if (this.commands.indexOf(command) < 0) {\n      this.commands.push(command);\n    }\n  },\n\n  /**\n   * Add event module.\n   * @param {Event} event The event module to be injected.\n   */\n  addEvent: function (event) {\n    if (!event || !_.isObject(event)) {\n      var err = new Error('Please inject a valid event object!');\n      debug(err);\n      throw err;\n    }\n\n    if (!event.payload && event.payload !== '') {\n      event.payload = this.defaultEventPayload;\n    }\n\n    if (this.events.indexOf(event) < 0) {\n      this.events.push(event);\n    }\n  },\n\n  /**\n   * Add businessRule module.\n   * @param {BusinessRule} businessRule The businessRule module to be injected.\n   */\n  addBusinessRule: function (businessRule) {\n    if (!businessRule || !_.isObject(businessRule)) {\n      var err = new Error('Please inject a valid businessRule object!');\n      debug(err);\n      throw err;\n    }\n\n    if (this.businessRules.indexOf(businessRule) < 0) {\n      businessRule.defineAggregate(this);\n      this.businessRules.push(businessRule);\n      this.businessRules = _.sortBy(this.businessRules, function(br) {\n        return br.priority;\n      });\n    }\n  },\n\n  /**\n   * Add commandHandler module.\n   * @param {CommandHandler} commandHandler The commandHandler module to be injected.\n   */\n  addCommandHandler: function (commandHandler) {\n    if (!commandHandler || !_.isObject(commandHandler) || !_.isFunction(commandHandler.useAggregate)) {\n      var err = new Error('Please inject a valid commandHandler object!');\n      debug(err);\n      throw err;\n    }\n\n    commandHandler.useAggregate(this);\n\n    if (this.commandHandlers.indexOf(commandHandler) < 0) {\n      this.commandHandlers.push(commandHandler);\n    }\n  },\n\n  /**\n   * Returns the command modules by command name.\n   * @param {String} name The command name.\n   * @returns {Array}\n   */\n  getCommandsByName: function (name) {\n    if (!name || !_.isString(name)) {\n      var err = new Error('Please pass a valid string as name!');\n      debug(err);\n      throw err;\n    }\n\n    return _.filter(this.commands, function (cmd) {\n      return cmd.name === name;\n    });\n  },\n\n  /**\n   * Returns the command module by command name and command version.\n   * @param {String} name    The command name.\n   * @param {Number} version The command version. [optional; default 0]\n   * @returns {Command}\n   */\n  getCommand: function (name, version) {\n    if (!name || !_.isString(name)) {\n      var err = new Error('Please pass a valid string as name!');\n      debug(err);\n      throw err;\n    }\n\n    version = version || 0;\n\n    if (!_.isNumber(version)) {\n      var err = new Error('Please pass a valid number as version!');\n      debug(err);\n      throw err;\n    }\n\n    return _.find(this.commands, function (cmd) {\n      return cmd.name === name && cmd.version === version;\n    });\n  },\n\n  /**\n   * Returns all command modules.\n   * @returns {Array}\n   */\n  getCommands: function () {\n    return this.commands;\n  },\n\n  /**\n   * Returns the event module by event name and event version.\n   * @param {String} name    The event name.\n   * @param {Number} version The event version. [optional; default 0]\n   * @returns {Event}\n   */\n  getEvent: function (name, version) {\n    if (!name || !_.isString(name)) {\n      var err = new Error('Please pass a valid string as name!');\n      debug(err);\n      throw err;\n    }\n\n    version = version || 0;\n\n    if (!_.isNumber(version)) {\n      var err = new Error('Please pass a valid number as version!');\n      debug(err);\n      throw err;\n    }\n\n    return _.find(this.events, function (evt) {\n      return evt.name === name && evt.version === version;\n    });\n  },\n\n  /**\n   * Returns all event modules.\n   * @returns {Array}\n   */\n  getEvents: function () {\n    return this.events;\n  },\n\n  /**\n   * Returns all business rule modules.\n   * @returns {Array}\n   */\n  getBusinessRules: function () {\n    return this.businessRules;\n  },\n\n  /**\n   * Returns all commandHandler modules.\n   * @returns {Array}\n   */\n  getCommandHandlers: function () {\n    return this.commandHandlers;\n  },\n\n  /**\n   * Returns the commandHandler module by command name and command version.\n   * @param {String} name    The command name.\n   * @param {Number} version The command version. [optional; default 0]\n   * @returns {CommandHandler}\n   */\n  getCommandHandler: function (name, version) {\n    if (!name || !_.isString(name)) {\n      var err = new Error('Please pass a valid string as name!');\n      debug(err);\n      throw err;\n    }\n\n    version = version || 0;\n\n    if (!_.isNumber(version)) {\n      var err = new Error('Please pass a valid number as version!');\n      debug(err);\n      throw err;\n    }\n\n    var handler =  _.find(this.commandHandlers, function (cmdHnd) {\n      return cmdHnd.name === name && cmdHnd.version === version;\n    });\n\n    if (handler) {\n      return handler;\n    }\n\n    if (!this.getCommand(name, version)) {\n      return null;\n    }\n\n    return this.defaultCommandHandler;\n  },\n\n  /**\n   * Returns a new aggregate model, to be used in the command and event functions.\n   * @param {String} id The aggregate id.\n   * @returns {AggregateModel}\n   */\n  create: function (id) {\n    if (!id || !_.isString(id)) {\n      var err = new Error('Please pass a valid string as id!');\n      debug(err);\n      throw err;\n    }\n\n    return new AggregateModel(id, this.modelInitValues);\n  },\n\n  /**\n   * Validates the requested command.\n   * @param {Object} cmd The command object\n   * @returns {ValidationError}\n   */\n  validateCommand: function (cmd) {\n    var cmdName = dotty.get(cmd, this.definitions.command.name);\n\n    if (!cmdName) {\n      var err = new Error('command has no command name in ' + this.definitions.command.name);\n      debug(err);\n      throw err;\n    }\n\n    var version = 0;\n    if (!!this.definitions.command.version) {\n      version = dotty.get(cmd, this.definitions.command.version);\n    }\n\n    var command = this.getCommand(cmdName, version);\n    if (!command) {\n      var err = new Error('Command \"' + cmdName + '\" not found!');\n      debug(err);\n      throw err;\n    }\n\n    return command.validate(cmd);\n  },\n  /**\n   * Checks for pre-load-conditions. This check will be done BEFORE the aggregate is locked and loaded.\n   * @param {Object}         cmd            The command that was handled.\n   * @param {Function}       callback       The function, that will be called when this action is completed.\n   *                                        `function(err){}`\n   */\n  checkPreLoadConditions: function (cmd, callback) {\n    var cmdName = dotty.get(cmd, this.definitions.command.name);\n\n    if (!cmdName) {\n      var err = new Error('command has no command name in ' + this.definitions.command.name);\n      debug(err);\n      throw err;\n    }\n\n    var version = 0;\n    if (!!this.definitions.command.version) {\n      version = dotty.get(cmd, this.definitions.command.version);\n    }\n\n    var command = this.getCommand(cmdName, version);\n    if (!command) {\n      var err = new Error('Command \"' + cmdName + '\" not found!');\n      debug(err);\n      throw err;\n    }\n\n    command.checkPreLoadConditions(cmd, callback);\n  },\n\n  /**\n   * Checks for pre-conditions.\n   * @param {Object}         cmd            The command that was handled.\n   * @param {AggregateModel} aggregateModel The aggregate values.\n   * @param {Function}       callback       The function, that will be called when this action is completed.\n   *                                        `function(err){}`\n   */\n  checkPreConditions: function (cmd, aggregateModel, callback) {\n    var cmdName = dotty.get(cmd, this.definitions.command.name);\n\n    if (!cmdName) {\n      var err = new Error('command has no command name in ' + this.definitions.command.name);\n      debug(err);\n      throw err;\n    }\n\n    var version = 0;\n    if (!!this.definitions.command.version) {\n      version = dotty.get(cmd, this.definitions.command.version);\n    }\n\n    var command = this.getCommand(cmdName, version);\n    if (!command) {\n      var err = new Error('Command \"' + cmdName + '\" not found!');\n      debug(err);\n      throw err;\n    }\n\n    command.checkPreConditions(cmd, aggregateModel, callback);\n  },\n\n  /**\n   * Checks business rules.\n   * @param {Object}   changed  The new aggregate values.\n   * @param {Object}   previous The previous aggregate values.\n   * @param {Array}    events   All new generated events.\n   * @param {Object}   command  The command that was handled.\n   * @param {Function} callback The function, that will be called when this action is completed.\n   *                            `function(err){}`\n   */\n  checkBusinessRules: function (changed, previous, events, command, callback) {\n    async.eachSeries(this.getBusinessRules(), function (rule, callback) {\n      rule.check(changed, previous, events, command, callback);\n    }, callback);\n  },\n\n  /**\n   * Get infos to load correct stream.\n   * @param {Object} cmd The command object.\n   * @returns {Array}\n   */\n  getLoadInfo: function (cmd) {\n    var cmdName = dotty.get(cmd, this.definitions.command.name);\n\n    if (!cmdName) {\n      var err = new Error('command has no command name in ' + this.definitions.command.name);\n      debug(err);\n      throw err;\n    }\n\n    var version = 0;\n    if (!!this.definitions.command.version) {\n      version = dotty.get(cmd, this.definitions.command.version);\n    }\n\n    var command = this.getCommand(cmdName, version);\n    if (!command) {\n      var aggregateId = dotty.get(cmd, this.definitions.command.aggregateId);\n      var aggregateName = this.name;\n      var contextName = this.context.name;\n\n      return [{\n        context: contextName,\n        aggregate: aggregateName,\n        aggregateId: aggregateId\n      }];\n    }\n\n    return command.getLoadInfo(cmd);\n  },\n\n  /**\n   * Handles the passed command and checks the business rules.\n   * @param {AggregateModel}  aggregateModel The aggregateModel that should be used.\n   * @param {Object}          cmd            The command that was handled.\n   * @param {Function}        callback       The function, that will be called when this action is completed.\n   *                                         `function(err){}`\n   */\n  handle: function (aggregateModel, cmd, callback) {\n    var cmdName = dotty.get(cmd, this.definitions.command.name);\n    if (!cmdName) {\n      var err = new Error('command has no command name in ' + this.definitions.command.name);\n      debug(err);\n      return callback(err);\n    }\n\n    var version = 0;\n    if (!!this.definitions.command.version) {\n      version = dotty.get(cmd, this.definitions.command.version);\n    }\n\n    var command = this.getCommand(cmdName, version);\n    if (!command) {\n      var err = new Error('Command \"' + cmdName + '\" not found!');\n      debug(err);\n      return callback(err);\n    }\n\n    var self = this;\n\n    aggregateModel.set = function () {\n      throw new Error('You are not allowed to set a value in this step!');\n    };\n\n    this.checkPreConditions(cmd, aggregateModel, function (err) {\n      if (err) {\n        return callback(err);\n      }\n\n      var previousModel = new AggregateModel(aggregateModel.id, aggregateModel);\n\n      // attach apply function\n      aggregateModel.apply = applyHelper(self, aggregateModel, cmd);\n\n      debug('handle command');\n      command.handle(cmd, aggregateModel);\n\n      // remove apply function\n      delete aggregateModel.apply;\n\n      var uncommittedEvents = aggregateModel.getUncommittedEvents();\n\n      async.each(uncommittedEvents, function (evt, callback) {\n        var isEvtIdDefined = !!dotty.get(evt, self.definitions.event.id);\n        if (isEvtIdDefined) {\n          debug('event id already defined');\n          return callback(null);\n        }\n\n        // generate new id for event\n        debug('generate new id for event');\n        self.getNewId(function (err, id) {\n          if (err) {\n            return callback(err);\n          }\n\n          dotty.put(evt, self.definitions.event.id, id);\n          callback(null);\n        });\n      }, function (err) {\n        if (err) {\n          return callback(err);\n        }\n\n        // check business rules\n        debug('check business rules');\n        self.checkBusinessRules(aggregateModel, previousModel, uncommittedEvents, cmd, function (err) {\n          if (!err) {\n            return callback(null);\n          }\n\n          // clean up...\n          aggregateModel.reset(previousModel);\n          aggregateModel.clearUncommittedEvents();\n          callback(err);\n        });\n      });\n    });\n  },\n\n  /**\n   * Applies the passed events to the passed aggregateModel.\n   * @param {Array || Object} events         The events that should be applied.\n   * @param {AggregateModel}  aggregateModel The aggregateModel that should be used.\n   * @param {boolean}         notSameOrigin  If true it's an indication to not throw if event handler not found.\n   */\n  apply: function (events, aggregateModel, notSameOrigin) {\n    if (!events) {\n      return;\n    }\n\n    if (!_.isArray(events)) {\n      events = [events];\n    }\n\n    var self = this;\n\n    events.forEach(function (evt) {\n      var evtName = dotty.get(evt, self.definitions.event.name);\n      if (!evtName) {\n        var err = new Error('event has no event name in ' + self.definitions.event.name);\n        debug(err);\n        throw err;\n      }\n\n      var version = 0;\n      if (!!self.definitions.event.version) {\n        version = dotty.get(evt, self.definitions.event.version);\n      }\n\n      var event = self.getEvent(evtName, version);\n\n      if (!event) {\n        if (notSameOrigin) {\n          debug('You don\\'t want to handle event \"' + evtName + '\" of other event stream');\n          return;\n        }\n        var err = new Error('Event \"' + evtName + '\" not found!');\n        debug(err);\n        throw err;\n      }\n\n      event.apply(evt, aggregateModel);\n    });\n  },\n\n  /**\n   * Loads the aggregateModel with the data of the snapshot and the events.\n   * And returns true if a new snapshot should be done.\n   * @param {AggregateModel}  aggregateModel The aggregateModel that should be used.\n   * @param {Object}          snapshot       The snapshot object.\n   * @param {Array}           events         The events that should be applied.\n   * @param {Number}          loadingTime    The loading time in ms of the eventstore data.\n   * @param {Object}          stream         The eventstream.\n   * @param {Array}           streams        All loaded eventstreams for this aggregate.\n   * @param {boolean}         notSameOrigin  If true it's an indication to not throw if event handler not found.\n   * @returns {boolean}\n   */\n  loadFromHistory: function (aggregateModel, snapshot, events, loadingTime, stream, streams, notSameOrigin) {\n    var self = this;\n\n    var isSnapshotNeeded = false;\n\n    if (snapshot) {\n      // load snapshot\n      debug('load snapshot ' + snapshot.id + ' from history', _.pick(snapshot, ['context', 'aggregate', 'version']), {\n        context: this.context.name,\n        aggregate: this.name,\n        version: this.version\n      });\n      if ((snapshot.context === this.context.name || !snapshot.context && this.context.name === '_general') &&\n          (snapshot.aggregate === this.name || !snapshot.aggregate) &&\n          snapshot.version === this.version) {\n        aggregateModel.set(snapshot.data);\n      } else {\n        if (!this.snapshotConversions[snapshot.context + '.' + snapshot.aggregate + '.' + snapshot.version]) {\n          var err = new Error('No snapshot conversion defined!');\n          debug(err);\n          throw err;\n        }\n        debug('convert snapshot from history');\n        this.snapshotConversions[snapshot.context + '.' + snapshot.aggregate + '.' + snapshot.version](snapshot.data, aggregateModel);\n        isSnapshotNeeded = true;\n      }\n      aggregateModel.setRevision({\n        context: stream.context,\n        aggregate: stream.aggregate,\n        aggregateId: stream.aggregateId\n      }, snapshot.revision + 1);\n    }\n\n    if (events && events.length > 0) {\n      // load events\n      debug('load events from history');\n      var maxRevision = _.reduce(events, function (res, evt) {\n        var rev = dotty.get(evt, self.definitions.event.revision);\n        if (rev > res) {\n          return rev;\n        }\n        return res;\n      }, 0);\n\n      if (!this.skipHistory || (this.skipHistory && this.applyLastEvent)) {\n        this.apply(events, aggregateModel, notSameOrigin);\n      }\n\n      aggregateModel.setRevision({\n        context: stream.context,\n        aggregate: stream.aggregate,\n        aggregateId: stream.aggregateId\n      }, maxRevision);\n\n      if (!isSnapshotNeeded) {\n        if (this.isSnapshotNeeded.length > 2) {\n          isSnapshotNeeded = this.isSnapshotNeeded(loadingTime, events, aggregateModel.toJSON(), streams);\n        } else {\n          isSnapshotNeeded = this.isSnapshotNeeded(loadingTime, events);\n        }\n      }\n    }\n\n    return isSnapshotNeeded;\n  },\n\n  /**\n   * Returns true if a new snapshot should be done.\n   * @param {Number} loadingTime    The loading time in ms of the eventstore data.\n   * @param {Array}  events         The loaded events.\n   * @param {Object} aggregateModel The aggregate json object. [could be used for other algorithms]\n   * @param {Array}  streams        All loaded eventstreams for this aggregate.\n   * @returns {boolean}\n   */\n  isSnapshotNeeded: function (loadingTime, events) {\n    var snapshotThreshold = 100;\n    if (this.options.snapshotThreshold) {\n      snapshotThreshold = this.options.snapshotThreshold;\n    }\n\n    if (this.options.snapshotThresholdMs) {\n      return loadingTime >= this.options.snapshotThresholdMs;\n    }\n\n    return events.length >= snapshotThreshold;\n  },\n\n  /**\n   * Checks if a snapshot should be ignored.\n   * @param {Object} snapshot       The the snapshot.\n   * @returns {boolean}\n   */\n  shouldIgnoreSnapshot: function (snapshot) {\n    if (!this.snapshotIgnores[snapshot.version]) {\n      return false;\n    }\n\n    return this.snapshotIgnores[snapshot.version](snapshot.data);\n  },\n\n  /**\n   * Defines the algorithm to identify if a snapshot is needed to be done.\n   * @param {Function} fn Function containing the algorithm. Should return true or false.\n   *                      `function(loadingTime, events, aggregateModel){}`\n   */\n  defineSnapshotNeed: function (fn) {\n    if (!_.isFunction(fn)) {\n      throw new Error('Please pass in a function');\n    }\n\n    this.isSnapshotNeeded = fn;\n    return this;\n  },\n\n  /**\n   * Defines a new conversion function for older snapshot versions.\n   * @param {Object}   meta Meta infos like: { version: 10 }\n   * @param {Function} fn   Function containing the conversion rule\n   *                        `function(snapshotData, aggregateModel){}`\n   * @returns {Aggregate}\n   */\n  defineSnapshotConversion: function (meta, fn) {\n    if (!_.isObject(meta) || meta.version === undefined || meta.version === null || !_.isNumber(meta.version)) {\n      throw new Error('Please pass in a version');\n    }\n    if (!_.isFunction(fn)) {\n      throw new Error('Please pass in a function');\n    }\n\n    this.snapshotConversionRegistrations.push({ meta: meta, fn: fn });\n    return this;\n  },\n\n  /**\n   * Defines a if a snapshot should be ignored. -> if true it will loads all events\n   * @param {Object}   meta Meta infos like: { version: 10 }\n   * @param {Function} fn   Function containing the check function [optional], default return true\n   *                        `function(snapshotData){ return true; }`\n   * @returns {Aggregate}\n   */\n  defineIgnoreSnapshot: function (meta, fn) {\n    if (!_.isObject(meta) || meta.version === undefined || meta.version === null || !_.isNumber(meta.version)) {\n      throw new Error('Please pass in a version');\n    }\n\n    if (!fn) {\n      this.snapshotIgnores[meta.version] = function () {\n        return true;\n      };\n      return this;\n    }\n\n    if (_.isBoolean(fn)) {\n      this.snapshotIgnores[meta.version] = function () {\n        return fn;\n      };\n      return this;\n    }\n\n    this.snapshotIgnores[meta.version] = fn;\n    return this;\n  },\n\n  /**\n   * Inject idGenerator function for aggregate id.\n   * @param   {Function}  fn The function to be injected.\n   * @returns {Aggregate}    to be able to chain...\n   */\n  defineAggregateIdGenerator: function (fn) {\n    if (fn.length === 0) {\n      fn = _.wrap(fn, function(func, callback) {\n        callback(null, func());\n      });\n    }\n\n    this.getNewAggregateId = fn;\n\n    return this;\n  }\n\n});\n\nmodule.exports = Aggregate;\n","/home/travis/build/npmtest/node-npmtest-cqrs-domain/node_modules/cqrs-domain/lib/aggregateModel.js":"'use strict';\n\nvar debug = require('debug')('domain:aggregate'),\n  dotty = require('dotty'),\n  _ = require('lodash'),\n  jsondate = require('jsondate');\n\n/**\n * Aggregate constructor\n * @param {String} id              The aggregate id.\n * @param {Object} modelInitValues Initialization values for model like: { emails: [] } [optional]\n * @constructor\n */\nfunction AggregateModel (id, modelInitValues) {\n  if (!id || !_.isString(id)) {\n    var err = new Error('No id injected!');\n    debug(err);\n    throw err;\n  }\n\n  this.id = id;\n\n  if (modelInitValues instanceof AggregateModel) {\n    this.attributes = modelInitValues.toJSON();\n  } else {\n    this.attributes = _.cloneDeep(modelInitValues || {});\n  }\n\n  this.attributes.id = this.id;\n  this.attributes._destroyed = this.attributes._destroyed || false;\n  this.attributes._revisions = this.attributes._revisions || {};\n  this.attributes._revision = this.attributes._revision || 0;\n\n  this.uncommittedEvents = [];\n}\n\nAggregateModel.prototype = {\n\n  /**\n   * Marks this aggregate as destroyed.\n   */\n  destroy: function () {\n    this.set('_destroyed', true);\n  },\n\n  /**\n   * Returns true if this aggregate is destroyed.\n   * @returns {boolean}\n   */\n  isDestroyed: function () {\n    return !!this.get('_destroyed');\n  },\n\n  /**\n   * Sets the revision for this aggregate.\n   * @param {Object} streamInfo The stream info.\n   * @param {Number} rev        The revision number.\n   */\n  setRevision: function (streamInfo, rev) {\n    this.set('_revision', rev);\n    streamInfo.context = streamInfo.context || '_general';\n    this.get('_revisions')[streamInfo.context + '_' + streamInfo.aggregate + '_' + streamInfo.aggregateId] = rev;\n  },\n\n  /**\n   * Returns the revision of this aggregate.\n   * @param {Object} streamInfo The stream info.\n   * @returns {Number}\n   */\n  getRevision: function (streamInfo) {\n    if (!streamInfo) {\n      return this.get('_revision');\n    }\n    streamInfo.context = streamInfo.context || '_general';\n    return this.get('_revisions')[streamInfo.context + '_' + streamInfo.aggregate + '_' + streamInfo.aggregateId] || 0;\n  },\n\n  /**\n   * Returns all uncommitted events.\n   * @returns {Array}\n   */\n  getUncommittedEvents: function () {\n    return this.uncommittedEvents;\n  },\n\n  /**\n   * Adds/Saves an uncommitted event.\n   * @param {Object} evt The event object.\n   */\n  addUncommittedEvent: function (evt) {\n    this.uncommittedEvents.push(evt);\n  },\n\n  /**\n   * Clears the internal uncomitted event list.\n   */\n  clearUncommittedEvents: function () {\n    this.uncommittedEvents = [];\n  },\n\n  /**\n   * The toJSON function will be called when JSON.stringify().\n   * @return {Object} A clean Javascript object containing all attributes.\n   */\n  toJSON: function () {\n    return jsondate.parse(JSON.stringify(this.attributes));\n    // return _.cloneDeep(this.attributes);\n  },\n\n  /**\n   * Sets attributes for the aggregate.\n   *\n   * @example:\n   *     aggregate.set('firstname', 'Jack');\n   *     // or\n   *     aggregate.set({\n   *          firstname: 'Jack',\n   *          lastname: 'X-Man'\n   *     });\n   */\n  set: function (data) {\n    if (arguments.length === 2) {\n      dotty.put(this.attributes, arguments[0], arguments[1]);\n    } else if (_.isObject(data)) {\n      for (var m in data) {\n        dotty.put(this.attributes, m, data[m]);\n      }\n    }\n  },\n\n  /**\n   * Gets an attribute of the vm.\n   * @param  {String} attr The attribute name.\n   * @return {Object}      The result value.\n   *\n   * @example:\n   *     aggregate.get('firstname'); // returns 'Jack'\n   */\n  get: function (attr) {\n    return dotty.get(this.attributes, attr);\n  },\n\n  /**\n   * Returns `true` if the attribute contains a value that is not null\n   * or undefined.\n   * @param  {String} attr The attribute name.\n   * @return {Boolean}     The result value.\n   *\n   * @example:\n   *     aggregate.has('firstname'); // returns true or false\n   */\n  has: function (attr) {\n    return (this.get(attr) !== null && this.get(attr) !== undefined);\n  },\n\n  /**\n   * Resets the attributes for the aggregate.\n   */\n  reset: function (data) {\n    if (data instanceof AggregateModel) {\n      this.attributes = data.toJSON();\n    } else {\n      this.attributes = _.cloneDeep(data || {});\n    }\n\n    this.attributes.id = this.id;\n    this.attributes._destroyed = this.attributes._destroyed || false;\n    this.attributes._revision = this.attributes._revision || 0;\n  }\n\n};\n\nmodule.exports = AggregateModel;\n","/home/travis/build/npmtest/node-npmtest-cqrs-domain/node_modules/cqrs-domain/lib/defaultCommandHandler.js":"'use strict';\n\nvar Definition = require('./definitionBase'),\n  util = require('util'),\n  _ = require('lodash'),\n  debug = require('debug')('domain:defaultCommandHandler'),\n  dotty = require('dotty'),\n  async = require('async'),\n  uuid = require('uuid').v4,\n  ConcurrencyError = require('./errors/concurrencyError'),\n  AggregateDestroyedError = require('./errors/aggregateDestroyedError'),\n  AggregateConcurrencyError = require('./errors/aggregateConcurrencyError'),\n  EventFromEventStore = require('eventstore/lib/event');\n\n/**\n * Returns a random number between passed values of min and max.\n * @param {Number} min The minimum value of the resulting random number.\n * @param {Number} max The maximum value of the resulting random number.\n * @returns {Number}\n */\nfunction randomBetween(min, max) {\n  return Math.round(min + Math.random() * (max - min));\n}\n\n/**\n * DefaultCommandHandler constructor\n * @param {Object}   meta  Meta infos like: { name: 'name', version: 1 }\n * @constructor\n */\nfunction DefaultCommandHandler (meta) {\n  Definition.call(this, meta);\n\n  this.id = uuid().toString();\n  this.queue = {};\n}\n\nutil.inherits(DefaultCommandHandler, Definition);\n\n_.extend(DefaultCommandHandler.prototype, {\n\n  /**\n   * Injects the needed aggregate.\n   * @param {Aggregate} aggregate The aggregate object to inject.\n   */\n  useAggregate: function (aggregate) {\n    if (!aggregate || !_.isObject(aggregate)) {\n      var err = new Error('Please pass a valid aggregate!');\n      debug(err);\n      throw err;\n    }\n    this.aggregate = aggregate;\n  },\n\n  /**\n   * Injects the needed eventStore.\n   * @param {Object} eventStore The eventStore object to inject.\n   */\n  useEventStore: function (eventStore) {\n    if (!eventStore || !_.isObject(eventStore)) {\n      var err = new Error('Please pass a valid eventStore!');\n      debug(err);\n      throw err;\n    }\n    this.eventStore = eventStore;\n  },\n\n  /**\n   * Injects the needed aggregateLock.\n   * @param {Object} aggregateLock The aggregateLock object to inject.\n   */\n  useAggregateLock: function (aggregateLock) {\n    if (!aggregateLock || !_.isObject(aggregateLock)) {\n      var err = new Error('Please pass a valid aggregateLock!');\n      debug(err);\n      throw err;\n    }\n    this.aggregateLock = aggregateLock;\n  },\n\n  /**\n   * Queues the passed command and its callback.\n   * @param {String}   aggId The passed aggregate id.\n   * @param {Object}   cmd   The command to be queued.\n   * @param {Function} clb   The callback of this command.\n   */\n  queueCommand: function (aggId, cmd, clb) {\n    if (!aggId || !_.isString(aggId)) {\n      var err = new Error('Please pass a valid aggregate id!');\n      debug(err);\n      throw err;\n    }\n    if (!cmd || !_.isObject(cmd)) {\n      var err = new Error('Please pass a valid command!');\n      debug(err);\n      throw err;\n    }\n    if (!clb || !_.isFunction(clb)) {\n      var err = new Error('Please pass a valid callback!');\n      debug(err);\n      throw err;\n    }\n\n    this.queue[aggId] = this.queue[aggId] || [];\n    this.queue[aggId].push({ command: cmd, callback: clb })\n  },\n\n  /**\n   * Returns next command in the queue\n   * @param {String} aggId The passed aggregate id.\n   * @returns {Object}\n   */\n  getNextCommandInQueue: function (aggId) {\n    if (!aggId || !_.isString(aggId)) {\n      var err = new Error('Please pass a valid aggregate id!');\n      debug(err);\n      throw err;\n    }\n\n    if (this.queue[aggId] && this.queue[aggId].length > 0) {\n      var nextCmd = this.queue[aggId][0];\n      return nextCmd;\n    }\n\n    return null;\n  },\n\n  /**\n   * Removes the passed command from the queue.\n   * @param {String} aggId The passed aggregate id.\n   * @param {Object} cmd   The command to be queued.\n   */\n  removeCommandFromQueue: function (aggId, cmd) {\n    if (!aggId || !_.isString(aggId)) {\n      var err = new Error('Please pass a valid aggregate id!');\n      debug(err);\n      throw err;\n    }\n\n    _.remove(this.queue[aggId], function (c) {\n      return c.command === cmd;\n    });\n  },\n\n  /**\n   * Locks the aggregate.\n   * @param {String}   aggregateId The passed aggregateId.\n   * @param {Function} callback    The function, that will be called when this action is completed.\n   *                               `function(err){}`\n   */\n  lockAggregate: function (aggregateId, callback) {\n    if (!aggregateId || !_.isString(aggregateId)) {\n      var err = new Error('Please pass a valid aggregateId!');\n      debug(err);\n      throw err;\n    }\n    if (!callback || !_.isFunction(callback)) {\n      var err = new Error('Please pass a valid callback!');\n      debug(err);\n      throw err;\n    }\n    this.aggregateLock.reserve(this.id, aggregateId, callback);\n  },\n\n\n  /**\n   * Loads the aggregate.\n   * @param {Object}   cmd         The command to be queued.\n   * @param {String}   aggregateId The passed aggregateId (default).\n   * @param {Function} callback    The function, that will be called when this action is completed.\n   *                               `function(err, aggregate, stream, isNewSnapshotNeeded){}`\n   */\n  loadAggregate: function (cmd, aggregateId, callback) {\n    if (!cmd || !_.isObject(cmd)) {\n      var err = new Error('Please pass a valid command!');\n      debug(err);\n      throw err;\n    }\n    if (!aggregateId || !_.isString(aggregateId)) {\n      var err = new Error('Please pass a valid aggregateId!');\n      debug(err);\n      throw err;\n    }\n    if (!callback || !_.isFunction(callback)) {\n      var err = new Error('Please pass a valid callback!');\n      debug(err);\n      throw err;\n    }\n\n    var hasAggregateName = !!this.definitions.command.aggregate;\n    var hasContextName = !!this.definitions.command.context;\n\n    var toLoad = this.aggregate.getLoadInfo(cmd);\n\n    var self = this;\n\n    var firstToLoad = toLoad.shift();\n    firstToLoad.aggregateId = firstToLoad.aggregateId || aggregateId;\n\n    var aggregate = this.aggregate.create(aggregateId);\n\n    var streams = [];\n\n    var isNewSnapShotNeeded = false;\n\n    if (this.aggregate.skipHistory) {\n      debug('skip history for ', firstToLoad);\n      if (this.aggregate.disablePersistence) {\n        debug('persistency is disabled for ', firstToLoad);\n        return callback(null, aggregate, streams);\n      }\n      var startLoadingOne = Date.now();\n      // load aggregate with every stream\n      this.eventStore.getLastEventAsStream(firstToLoad, function(err, stream) {\n        if (err) {\n          return callback(err);\n        }\n\n        var lastStreamRevInLoop = null;\n        var events = _.map(stream.events, function (streamEvent) {\n          if (lastStreamRevInLoop !== null && lastStreamRevInLoop + 1 !== streamEvent.streamRevision) {\n            var msg = 'WARNING!!! Inconsistent event stream! Event with id (' + streamEvent.id + ') has a streamRevision of ' + streamEvent.streamRevision + ', but streamRevision in last event was ' + lastStreamRevInLoop + '!';\n            var e = new Error(msg);\n            debug(e);\n            console.log(msg);\n          }\n          lastStreamRevInLoop = streamEvent.streamRevision;\n          return streamEvent.payload;\n        });\n\n        var loadingTime = Date.now() - startLoadingOne;\n        debug('needed ' + loadingTime + 'ms to load last event from the eventstore for: ', firstToLoad);\n\n        streams.push(stream);\n\n        self.aggregate.loadFromHistory(aggregate, null, events, loadingTime, stream, streams);\n\n        // callback with the aggregate and the streams\n        callback(null, aggregate, streams);\n      });\n      return;\n    }\n\n    function regularLoad (callback) {\n      if (!hasAggregateName) {\n        delete firstToLoad.aggregate;\n      }\n\n      if (!hasContextName) {\n        delete firstToLoad.context;\n      }\n\n      var startLoading = Date.now();\n\n      // load aggregate with every stream\n      self.eventStore.getFromSnapshot(firstToLoad, function(err, snapshot, stream) {\n        if (err) {\n          return callback(err);\n        }\n\n        var ignoreSnapshot = false;\n\n        if (snapshot) ignoreSnapshot = self.aggregate.shouldIgnoreSnapshot(snapshot);\n\n        if (!ignoreSnapshot) {\n          var lastStreamRevInLoop = null;\n          var events = _.map(stream.events, function (streamEvent) {\n            if (lastStreamRevInLoop !== null && lastStreamRevInLoop + 1 !== streamEvent.streamRevision) {\n              var msg = 'WARNING!!! Inconsistent event stream! Event with id (' + streamEvent.id + ') has a streamRevision of ' + streamEvent.streamRevision + ', but streamRevision in last event was ' + lastStreamRevInLoop + '!';\n              var e = new Error(msg);\n              debug(e);\n              console.log(msg);\n            }\n            lastStreamRevInLoop = streamEvent.streamRevision;\n            return streamEvent.payload;\n          });\n\n          var loadingTime = Date.now() - startLoading;\n          var addon = '';\n          if (snapshot) {\n            addon = ' and snapshot';\n          }\n          debug('needed ' + loadingTime + 'ms to load events' + addon + ' from the eventstore for: ', firstToLoad);\n\n          isNewSnapShotNeeded = self.aggregate.loadFromHistory(aggregate, snapshot, [], loadingTime, stream);\n\n          streams.push(stream);\n\n          callback(null, events, stream, startLoading);\n          return;\n        }\n\n        debug('skipping snapshot, and load whole event stream');\n\n        startLoading = Date.now();\n        self.eventStore.getEventStream(firstToLoad, function(err, stream) {\n          if (err) {\n            return callback(err);\n          }\n\n          var lastStreamRevInLoop = null;\n          var events = _.map(stream.events, function (streamEvent) {\n            if (lastStreamRevInLoop !== null && lastStreamRevInLoop + 1 !== streamEvent.streamRevision) {\n              var msg = 'WARNING!!! Inconsistent event stream! Event with id (' + streamEvent.id + ') has a streamRevision of ' + streamEvent.streamRevision + ', but streamRevision in last event was ' + lastStreamRevInLoop + '!';\n              var e = new Error(msg);\n              debug(e);\n              console.log(msg);\n            }\n            lastStreamRevInLoop = streamEvent.streamRevision;\n            return streamEvent.payload;\n          });\n\n          loadingTime = Date.now() - startLoading;\n\n          debug('needed ' + loadingTime + 'ms to load events from the eventstore');\n\n          isNewSnapShotNeeded = self.aggregate.loadFromHistory(aggregate, null, events, loadingTime, stream);\n\n          streams.push(stream);\n\n          callback(null, events, stream, startLoading);\n        });\n      });\n    }\n\n    regularLoad(function (err, events, stream, totalLoadingTime) {\n      if (err) {\n        return callback(err);\n      }\n\n      async.eachSeries(toLoad, function (loadInfo, callback) {\n        loadInfo.aggregateId = loadInfo.aggregateId || aggregateId;\n\n        if (!hasAggregateName) {\n          delete loadInfo.aggregate;\n        }\n\n        if (!hasContextName) {\n          delete loadInfo.context;\n        }\n\n        var rev = aggregate.getRevision(loadInfo);\n\n        var startLoading = Date.now();\n\n        // load aggregate with every stream\n        self.eventStore.getEventStream(loadInfo, rev, function(err, str) {\n          if (err) {\n            return callback(err);\n          }\n\n          var lastStreamRevInLoop = null;\n          var evts = _.map(str.events, function (streamEvent) {\n            if (lastStreamRevInLoop !== null && lastStreamRevInLoop + 1 !== streamEvent.streamRevision) {\n              var msg = 'WARNING!!! Inconsistent event stream! Event with id (' + streamEvent.id + ') has a streamRevision of ' + streamEvent.streamRevision + ', but streamRevision in last event was ' + lastStreamRevInLoop + '!';\n              var e = new Error(msg);\n              debug(e);\n              console.log(msg);\n            }\n            lastStreamRevInLoop = streamEvent.streamRevision;\n            return streamEvent.payload;\n          });\n\n          var loadingTime = Date.now() - startLoading;\n          debug('needed ' + loadingTime + 'ms to load events from the eventstore for: ', loadInfo);\n\n          var notSameOrigin = loadInfo.aggregate && loadInfo.aggregate !== self.aggregate.name ||\n                              loadInfo.context && loadInfo.context !== self.aggregate.context.name;\n\n          var snapNeed = self.aggregate.loadFromHistory(aggregate, null, evts, loadingTime, str, null, notSameOrigin);\n\n          if (!isNewSnapShotNeeded) {\n            isNewSnapShotNeeded = snapNeed;\n          }\n\n          streams.push(str);\n\n          callback(null);\n        });\n      }, function (err) {\n        if (err) {\n          return callback(err);\n        }\n\n        var loadingTime = Date.now() - totalLoadingTime;\n\n        var snapNeed = self.aggregate.loadFromHistory(aggregate, null, events, loadingTime, stream, streams);\n\n        if (!isNewSnapShotNeeded) {\n          isNewSnapShotNeeded = snapNeed;\n        }\n\n        debug('check if new snapshot is needed');\n        if (isNewSnapShotNeeded) {\n          self.createSnapshot(aggregate, stream);\n        }\n\n        // callback with the aggregate and the streams\n        callback(null, aggregate, streams);\n      });\n    });\n  },\n\n  /**\n   * Creates a new snapshot.\n   * @param {AggregateModel} aggregate The passed aggregate.\n   * @param {Object}         stream    The event stream.\n   * @param {Function}       callback  The function, that will be called when this action is completed. [optional]\n   *                                   `function(err){}`\n   */\n  createSnapshot: function (aggregate, stream, callback) {\n    if (!aggregate || !_.isObject(aggregate)) {\n      var err = new Error('Please pass a valid aggregate!');\n      debug(err);\n      throw err;\n    }\n    if (!stream || !_.isObject(stream)) {\n      var err = new Error('Please pass a valid aggregate!');\n      debug(err);\n      throw err;\n    }\n\n    var hasAggregateName = !!this.definitions.command.aggregate;\n    var hasContextName = !!this.definitions.command.context;\n\n    var query = {\n      aggregateId: aggregate.id\n    };\n\n    if (hasAggregateName) {\n      query.aggregate = this.aggregate.name;\n    }\n\n    if (hasContextName) {\n      query.context = this.aggregate.context.name;\n    }\n\n    query.data = aggregate.toJSON();\n    query.revision = stream.lastRevision;\n    query.version = this.aggregate.version;\n\n    var self = this;\n\n    process.nextTick(function() {\n      debug('cerate new snapshot');\n      self.eventStore.createSnapshot(query, function (err) {\n        if (err) {\n          debug(err);\n          if (callback) callback(err);\n          return;\n        }\n        debug('snapshot created');\n        if (callback) callback(null);\n      });\n    });\n  },\n\n  /**\n   * Returns an error if the aggregate is destroyed.\n   * @param {AggregateModel} aggregate The passed aggregate.\n   * @param {Object}         cmd       The command.\n   * @returns {AggregateDestroyedError}\n   */\n  isAggregateDestroyed: function (aggregate, cmd) {\n    if (!aggregate || !_.isObject(aggregate)) {\n      var err = new Error('Please pass a valid aggregate!');\n      debug(err);\n      throw err;\n    }\n    if (!cmd || !_.isObject(cmd)) {\n      var err = new Error('Please pass a valid command!');\n      debug(err);\n      throw err;\n    }\n\n    var contextName, aggregateName, aggregateId;\n\n    if (!!this.definitions.command.context) {\n      contextName = dotty.get(cmd, this.definitions.command.context);\n    }\n\n    if (!!this.definitions.command.aggregate) {\n      aggregateName = dotty.get(cmd, this.definitions.command.aggregate);\n    }\n\n    if (!!this.definitions.command.aggregateId) {\n      aggregateId = dotty.get(cmd, this.definitions.command.aggregateId);\n    }\n\n    var streamInfo = {\n      context: contextName,\n      aggregate: aggregateName,\n      aggregateId: aggregateId\n    };\n\n    if (aggregate.isDestroyed()) {\n      return new AggregateDestroyedError('Aggregate has already been destroyed!', {\n        aggregateId: aggregate.id,\n        aggregateRevision: aggregate.getRevision(streamInfo)\n      });\n    }\n\n    return null;\n  },\n\n  /**\n   * Returns an error if the revision does not match.\n   * @param {AggregateModel} aggregate The passed aggregate.\n   * @param {Object}         cmd       The command.\n   * @returns {AggregateConcurrencyError}\n   */\n  isRevisionWrong: function (aggregate, cmd) {\n    if (!aggregate || !_.isObject(aggregate)) {\n      var err = new Error('Please pass a valid aggregate!');\n      debug(err);\n      throw err;\n    }\n    if (!cmd || !_.isObject(cmd)) {\n      var err = new Error('Please pass a valid command!');\n      debug(err);\n      throw err;\n    }\n\n    var hasRevision = !!this.definitions.command.revision;\n\n    if (!hasRevision) {\n      return null;\n    }\n\n    var revisionInCommand = dotty.get(cmd, this.definitions.command.revision);\n    if (revisionInCommand === null || revisionInCommand === undefined) {\n      return null;\n    }\n\n    var contextName, aggregateName, aggregateId;\n\n    if (!!this.definitions.command.context) {\n      contextName = dotty.get(cmd, this.definitions.command.context);\n    }\n\n    if (!!this.definitions.command.aggregate) {\n      aggregateName = dotty.get(cmd, this.definitions.command.aggregate);\n    }\n\n    if (!!this.definitions.command.aggregateId) {\n      aggregateId = dotty.get(cmd, this.definitions.command.aggregateId);\n    }\n\n    var streamInfo = {\n      context: contextName,\n      aggregate: aggregateName,\n      aggregateId: aggregateId\n    };\n\n    if (revisionInCommand === aggregate.getRevision(streamInfo)) {\n      return null;\n    }\n\n    return new AggregateConcurrencyError('Actual revision in command is \"' + revisionInCommand + '\", but expected is \"' + aggregate.getRevision(streamInfo) + '\"!', {\n      aggregateId: aggregate.id,\n      aggregateRevision: aggregate.getRevision(streamInfo),\n      commandRevision: revisionInCommand\n    });\n  },\n\n  /**\n   * Returns an error if the command is not valid.\n   * @param {Object} cmd The command.\n   * @returns {ValidationError}\n   */\n  validateCommand: function (cmd) {\n    if (!cmd || !_.isObject(cmd)) {\n      var err = new Error('Please pass a valid command!');\n      debug(err);\n      throw err;\n    }\n    return this.aggregate.validateCommand(cmd);\n  },\n\n  checkPreLoadConditions: function (cmd, clb) {\n    this.aggregate.checkPreLoadConditions(cmd, clb);\n  },\n\n  /**\n   * Returns an error if verification fails.\n   * @param {AggregateModel} aggregate The passed aggregate.\n   * @param {Object}         cmd       The command.\n   * @returns {Error}\n   */\n  verifyAggregate: function (aggregate, cmd) {\n    if (!aggregate || !_.isObject(aggregate)) {\n      var err = new Error('Please pass a valid aggregate!');\n      debug(err);\n      throw err;\n    }\n    if (!cmd || !_.isObject(cmd)) {\n      var err = new Error('Please pass a valid command!');\n      debug(err);\n      throw err;\n    }\n\n    var reason = this.isAggregateDestroyed(aggregate, cmd);\n    if (reason) {\n      return reason;\n    }\n\n    reason = this.isRevisionWrong(aggregate, cmd);\n    if (reason) {\n      return reason;\n    }\n  },\n\n  /**\n   * Handles the command by passing it to the handle function of the aggregate.\n   * @param {AggregateModel} aggregate The passed aggregate.\n   * @param {Object}         cmd       The command.\n   * @param {Function}       callback  The function, that will be called when this action is completed.\n   *                                   `function(err){}`\n   */\n  letHandleCommandByAggregate: function (aggregate, cmd, callback) {\n    if (!aggregate || !_.isObject(aggregate)) {\n      var err = new Error('Please pass a valid aggregate!');\n      debug(err);\n      throw err;\n    }\n    if (!cmd || !_.isObject(cmd)) {\n      var err = new Error('Please pass a valid command!');\n      debug(err);\n      throw err;\n    }\n    if (!callback || !_.isFunction(callback)) {\n      var err = new Error('Please pass a valid function!');\n      debug(err);\n      throw err;\n    }\n\n    this.aggregate.handle(aggregate, cmd, callback);\n  },\n\n  /**\n   * Checks if the aggregate lock is ok.\n   * @param {String}   aggregateId The passed aggregateId.\n   * @param {Function} callback    The function, that will be called when this action is completed.\n   *                               `function(err){}`\n   */\n  checkAggregateLock: function (aggregateId, callback) {\n    if (!aggregateId || !_.isString(aggregateId)) {\n      var err = new Error('Please pass a valid aggregateId!');\n      debug(err);\n      throw err;\n    }\n    if (!callback || !_.isFunction(callback)) {\n      var err = new Error('Please pass a valid callback!');\n      debug(err);\n      throw err;\n    }\n\n    var self = this;\n\n    this.aggregateLock.getAll(aggregateId, function (err, workerIds) {\n      if (err) {\n        return callback(err);\n      }\n\n      if (workerIds.length === 0 || (workerIds.length === 1 && workerIds[0] === self.id)) {\n        return callback(null);\n      }\n\n      var err = new ConcurrencyError('Aggregate is locked by an other command handler!');\n      debug(err);\n      callback(err);\n    });\n  },\n\n  /**\n   * Resolves if the aggregate lock.\n   * @param {String}   aggregateId The passed aggregateId.\n   * @param {Function} callback    The function, that will be called when this action is completed.\n   *                               `function(err){}`\n   */\n  resolveAggregateLock: function (aggregateId, callback) {\n    if (!aggregateId || !_.isString(aggregateId)) {\n      var err = new Error('Please pass a valid aggregateId!');\n      debug(err);\n      throw err;\n    }\n    if (!callback || !_.isFunction(callback)) {\n      var err = new Error('Please pass a valid callback!');\n      debug(err);\n      throw err;\n    }\n\n    this.aggregateLock.resolve(aggregateId, callback);\n  },\n\n  /**\n   * Saves the uncommitted events of an aggregate in the eventstore.\n   * @param {AggregateModel} aggregate The passed aggregate.\n   * @param {Array}          streams   The event streams.\n   * @param {Function}       callback  The function, that will be called when this action is completed.\n   *                                   `function(err, eventsToDispatch){}`\n   */\n  commit: function (aggregate, streams, callback) {\n    if (!aggregate || !_.isObject(aggregate)) {\n      var err = new Error('Please pass a valid aggregate!');\n      debug(err);\n      throw err;\n    }\n    if (!streams || !_.isArray(streams)) {\n      var err = new Error('Please pass valid streams!');\n      debug(err);\n      throw err;\n    }\n    if (!callback || !_.isFunction(callback)) {\n      var err = new Error('Please pass a valid callback!');\n      debug(err);\n      throw err;\n    }\n\n    var uncommitedEvents = aggregate.getUncommittedEvents();\n\n    if (uncommitedEvents.length === 0) {\n      debug('no events generated');\n      return callback(null, []);\n    }\n\n    var self = this;\n\n    var evtsToDispatch = [];\n    var fakeEventStream = {\n      aggregateId: dotty.get(uncommitedEvents[0], self.definitions.event.aggregateId),\n      aggregate: dotty.get(uncommitedEvents[0], self.definitions.event.aggregate),\n      context: dotty.get(uncommitedEvents[0], self.definitions.event.context),\n      uncommittedEvents: []\n    };\n\n    for (var e in uncommitedEvents) {\n      var evt = uncommitedEvents[e];\n\n      var stream = _.find(streams, function (s) {\n        return s.context === dotty.get(evt, self.definitions.event.context) &&\n          s.aggregate === dotty.get(evt, self.definitions.event.aggregate) &&\n          s.aggregateId === dotty.get(evt, self.definitions.event.aggregateId);\n      });\n\n      if (!stream && !self.aggregate.disablePersistence) {\n        debug('no stream found for:', evt);\n        return callback(new Error('No event stream found for evt with id:' + dotty.get(evt, self.definitions.event.id)));\n      }\n\n      if (stream) stream.addEvent(evt);\n\n      if (!stream && self.aggregate.disablePersistence) {\n        var eventStoreEvent = new EventFromEventStore(fakeEventStream, evt, self.eventStore.eventMappings);\n        eventStoreEvent.disablePersistence = true;\n        eventStoreEvent.id = uuid().toString();\n        evtsToDispatch.push(eventStoreEvent);\n      }\n    }\n\n    async.each(streams, function (stream, callback) {\n      if (self.aggregate.disablePersistence) {\n        for (var ie = 0, evtLength = stream.uncommittedEvents.length; ie < evtLength; ie++) {\n          stream.uncommittedEvents[ie].disablePersistence = true;\n          stream.uncommittedEvents[ie].id = uuid().toString();\n          evtsToDispatch.push(stream.uncommittedEvents[ie]);\n        }\n        return callback(null);\n      }\n      stream.commit(function (err, stream) {\n        if (err) {\n          return callback(err);\n        }\n\n        evtsToDispatch = evtsToDispatch.concat(stream.eventsToDispatch);\n\n        callback(null);\n      });\n    }, function (err) {\n      if (err) {\n        return callback(err);\n      }\n\n      callback(null, evtsToDispatch);\n    });\n  },\n\n  /**\n   * Executes the default workflow to handle a command.\n   * @param {String}   aggId    The passed aggregate id.\n   * @param {Object}   cmd      The passed command.\n   * @param {Function} callback The function, that will be called when this action is completed.\n   *                            `function(err, eventsToDispatch){}`\n   */\n  workflow: function (aggId, cmd, callback) {\n    if (!aggId || !_.isString(aggId)) {\n      var err = new Error('Please pass a valid aggregate id!');\n      debug(err);\n      throw err;\n    }\n    if (!cmd || !_.isObject(cmd)) {\n      var err = new Error('Please pass a valid command!');\n      debug(err);\n      throw err;\n    }\n    if (!callback || !_.isFunction(callback)) {\n      var err = new Error('Please pass a valid callback!');\n      debug(err);\n      throw err;\n    }\n\n    var self = this;\n\n    var agg = null;\n    var meta = {\n      aggregateId: aggId,\n      aggregate: this.aggregate ? this.aggregate.name : undefined,\n      context: this.aggregate && this.aggregate.context ? this.aggregate.context.name : undefined\n    };\n\n    var concatenatedId = this.getConcatenatedId(aggId, cmd);\n\n    var hadNoAggregateId = !dotty.exists(cmd, this.definitions.command.aggregateId);\n\n    async.waterfall([\n\n      // validate command\n      function (clb) {\n        debug('validate command');\n\n        var valErr = null;\n        try {\n          valErr = self.validateCommand(cmd);\n        } catch (e) {\n          valErr = e;\n        }\n        clb(valErr);\n      },\n\n//      // check aggregate lock\n//      function (clb) {\n//        if (hadNoAggregateId) return clb(null);\n//        debug('check aggregate lock');\n//        self.checkAggregateLock(aggId, clb);\n//      },\n\n      // check the pre-load conditions: this is run before the aggregate is locked to allow non-(b)locking checks\n      function (clb) {\n        debug('check the pre-load conditions');\n        self.checkPreLoadConditions(cmd, clb);\n      },\n\n      // lock aggregate\n      function (clb) {\n        if (hadNoAggregateId) return clb(null);\n        debug('lock aggregate');\n        self.lockAggregate(concatenatedId, clb);\n      },\n\n      // load aggregate\n      function (clb) {\n        debug('load aggregate');\n        self.loadAggregate(cmd, aggId, clb);\n      },\n\n      // verify aggregate\n      function (aggregate, streams, clb) {\n        agg = aggregate; // save it temporary so we can use it in the callback\n\n        debug('verify aggregate');\n        var err = self.verifyAggregate(aggregate, cmd);\n        if (err) {\n          return clb(err);\n        }\n        clb(null, aggregate, streams);\n      },\n\n      // handle command and check business rules\n      function (aggregate, streams, clb) {\n        debug('handle command');\n        self.letHandleCommandByAggregate(aggregate, cmd, function (err) { // err is a business rule error\n          if (err) {\n            return clb(err);\n          }\n          clb(null, aggregate, streams);\n        });\n      },\n\n      // check aggregate lock\n      function (aggregate, streams, clb) {\n        if (hadNoAggregateId) return clb(null, aggregate, streams);\n        debug('check aggregate lock');\n        self.checkAggregateLock(concatenatedId, function (err) {\n          clb(err, aggregate, streams);\n        });\n      },\n\n      // commit new aggregate events\n      function (aggregate, streams, clb) {\n        debug('commit new aggregate events');\n        self.commit(aggregate, streams, clb);\n      }\n\n    ], function (err, eventsToDispatch) {\n      if (agg && agg.getRevision() === 0) {\n        agg = null;\n      }\n\n      if (hadNoAggregateId) {\n        if (callback.length > 2) {\n          return callback(err, eventsToDispatch || null, agg ? agg.toJSON() : null, meta);\n        }\n\n        return callback(err, eventsToDispatch || null);\n      }\n\n      // unlock...\n      debug('unlock aggregate');\n\n      self.resolveAggregateLock(concatenatedId, function (errLock) {\n        if (errLock) {\n          debug(errLock);\n          return callback(errLock);\n        }\n\n        if (err) {\n          debug(err);\n\n          if (err instanceof ConcurrencyError) {\n            var retryIn = randomBetween(0, self.options.retryOnConcurrencyTimeout); // could be overwritten in a custom commandHandler?\n            debug('retry in ' + retryIn + 'ms');\n            setTimeout(function() {\n              self.workflow(aggId, cmd, callback);\n            }, retryIn);\n            return;\n          }\n\n          if (callback.length > 2) {\n            return callback(err, null, agg ? agg.toJSON() : null, meta);\n          }\n\n          return callback(err, null);\n        }\n\n        if (callback.length > 2) {\n          return callback(null, eventsToDispatch || null, agg ? agg.toJSON() : null, meta);\n        }\n\n        callback(null, eventsToDispatch || null);\n      });\n    });\n  },\n\n  /**\n   * Returns the concatenated id (more unique)\n   * @param {String}   aggId The passed aggregate id.\n   * @param {Object}   cmd   The passed command.\n   * @returns {string}\n   */\n  getConcatenatedId: function (aggId, cmd) {\n    var aggregate = '';\n    if (dotty.exists(cmd, this.definitions.command.aggregate)) {\n      aggregate = dotty.get(cmd, this.definitions.command.aggregate);\n    }\n\n    var context = '';\n    if (dotty.exists(cmd, this.definitions.command.context)) {\n      context = dotty.get(cmd, this.definitions.command.context);\n    }\n\n    return context + aggregate + aggId;\n  },\n\n  /**\n   * Handles the passed command\n   * @param {Object}   cmd      The passed command\n   * @param {Function} callback The function, that will be called when this action is completed.\n   *                            `function(err, evts){}`\n   */\n  handle: function (cmd, callback) {\n    if (!cmd || !_.isObject(cmd)) {\n      var err = new Error('Please pass a valid command!');\n      debug(err);\n      throw err;\n    }\n    if (!callback || !_.isFunction(callback)) {\n      var err = new Error('Please pass a valid callback!');\n      debug(err);\n      throw err;\n    }\n\n    var self = this;\n\n    function _handle (aggId) {\n      var concatenatedId = self.getConcatenatedId(aggId, cmd);\n\n      var isFirst = !self.getNextCommandInQueue(concatenatedId);\n\n      self.queueCommand(concatenatedId, cmd, callback);\n\n      if (!isFirst) {\n        return;\n      }\n\n      (function handleNext (aggregateId, c) {\n        var concId = self.getConcatenatedId(aggregateId, c);\n        var cmdEntry = self.getNextCommandInQueue(concId);\n        if (cmdEntry) {\n          if (cmdEntry.callback.length > 2) {\n            self.workflow(aggregateId, cmdEntry.command, function (err, evts, aggData, meta) {\n              self.removeCommandFromQueue(concId, cmdEntry.command);\n              handleNext(aggregateId, cmdEntry.command);\n              cmdEntry.callback(err, evts, aggData, meta);\n            });\n            return;\n          }\n          self.workflow(aggregateId, cmdEntry.command, function (err, evts) {\n            self.removeCommandFromQueue(concId, cmdEntry.command);\n            handleNext(aggregateId, cmdEntry.command);\n            cmdEntry.callback(err, evts);\n          });\n        }\n      })(aggId, cmd);\n    }\n\n    if (dotty.exists(cmd, this.definitions.command.aggregateId)) {\n      return _handle(dotty.get(cmd, this.definitions.command.aggregateId));\n    }\n\n    debug('no aggregateId in command, so generate a new one');\n\n    this.getNewAggregateId(function (err, id) {\n      if (err) {\n        debug(err);\n        return callback(err);\n      }\n\n      return _handle(id);\n    });\n  },\n\n  /**\n   * Inject idGenerator function for aggregate id.\n   * @param   {Function} fn           The function to be injected.\n   * @returns {DefaultCommandHandler} to be able to chain...\n   */\n  aggregateIdGenerator: function (fn) {\n    if (fn.length === 0) {\n      fn = _.wrap(fn, function(func, callback) {\n        callback(null, func());\n      });\n    }\n\n    this.getNewAggregateIdFn = fn;\n\n    return this;\n  },\n\n  /**\n   * IdGenerator function for aggregate id.\n   * @param {Function} callback The function, that will be called when this action is completed.\n   *                            `function(err, newId){}`\n   */\n  getNewAggregateId: function (callback) {\n    var getNewIdFn = this.eventStore.getNewId.bind(this.eventStore);\n    if (this.aggregate && this.aggregate.getNewAggregateId) {\n      getNewIdFn = this.aggregate.getNewAggregateId.bind(this.aggregate);\n    } else if (this.getNewAggregateIdFn) {\n      getNewIdFn = this.getNewAggregateIdFn.bind(this);\n    }\n\n    getNewIdFn(callback);\n  }\n\n});\n\nmodule.exports = DefaultCommandHandler;\n","/home/travis/build/npmtest/node-npmtest-cqrs-domain/node_modules/cqrs-domain/lib/errors/concurrencyError.js":"'use strict';\n\n// Grab the util module that's bundled with Node\nvar util = require('util');\n\n// Create a new custom Error constructor\nfunction ConcurrencyError(msg, more) {\n  // Pass the constructor to V8's\n  // captureStackTrace to clean up the output\n  Error.captureStackTrace(this, ConcurrencyError);\n\n  // If defined, store a custom error message\n  if (msg) {\n    this.message = msg;\n  }\n}\n\n// Extend our custom Error from Error\nutil.inherits(ConcurrencyError, Error);\n\n// Give our custom error a name property. Helpful for logging the error later.\nConcurrencyError.prototype.name = ConcurrencyError.name;\n\nmodule.exports = ConcurrencyError;\n","/home/travis/build/npmtest/node-npmtest-cqrs-domain/node_modules/cqrs-domain/lib/errors/aggregateDestroyedError.js":"'use strict';\n\n// Grab the util module that's bundled with Node\nvar util = require('util');\n\n// Create a new custom Error constructor\nfunction AggregateDestroyedError(msg, more) {\n  // Pass the constructor to V8's\n  // captureStackTrace to clean up the output\n  Error.captureStackTrace(this, AggregateDestroyedError);\n\n  // If defined, store a custom error message\n  if (msg) {\n    this.message = msg;\n  }\n\n  // If defined, store more infos\n  if (more) {\n    this.more = more;\n  }\n}\n\n// Extend our custom Error from Error\nutil.inherits(AggregateDestroyedError, Error);\n\n// Give our custom error a name property. Helpful for logging the error later.\nAggregateDestroyedError.prototype.name = AggregateDestroyedError.name;\n\nmodule.exports = AggregateDestroyedError;\n","/home/travis/build/npmtest/node-npmtest-cqrs-domain/node_modules/cqrs-domain/lib/errors/aggregateConcurrencyError.js":"'use strict';\n\n// Grab the util module that's bundled with Node\nvar util = require('util');\n\n// Create a new custom Error constructor\nfunction AggregateConcurrencyError(msg, more) {\n  // Pass the constructor to V8's\n  // captureStackTrace to clean up the output\n  Error.captureStackTrace(this, AggregateConcurrencyError);\n\n  // If defined, store a custom error message\n  if (msg) {\n    this.message = msg;\n  }\n\n  // If defined, store more infos\n  if (more) {\n    this.more = more;\n  }\n}\n\n// Extend our custom Error from Error\nutil.inherits(AggregateConcurrencyError, Error);\n\n// Give our custom error a name property. Helpful for logging the error later.\nAggregateConcurrencyError.prototype.name = AggregateConcurrencyError.name;\n\nmodule.exports = AggregateConcurrencyError;\n","/home/travis/build/npmtest/node-npmtest-cqrs-domain/node_modules/cqrs-domain/lib/definitions/command.js":"'use strict';\n\nvar Definition = require('../definitionBase'),\n  util = require('util'),\n  _ = require('lodash'),\n  dotty = require('dotty'),\n  async = require('async'),\n  debug = require('debug')('domain:command'),\n  BusinessRuleError = require('../errors/businessRuleError');\n\n/**\n * Command constructor\n * @param {Object}   meta  Meta infos like: { name: 'name', version: 1, payload: 'some.path' }\n * @param {Function} cmdFn Function handle\n *                         `function(cmd, aggregateModel){}`\n * @constructor\n */\nfunction Command (meta, cmdFn) {\n  Definition.call(this, meta);\n\n  meta = meta || {};\n\n  if (!cmdFn || !_.isFunction(cmdFn)) {\n    var err = new Error('Command function not injected!');\n    debug(err);\n    throw err;\n  }\n\n  // this.source = meta.source || {};\n\n  this.version = meta.version || 0;\n  this.payload = meta.payload === '' ? meta.payload : (meta.payload || null);\n  if (meta.existing) {\n    this.existing = true;\n  } else if (meta.existing === false) {\n    this.existing = false;\n  } else {\n    this.existing = undefined;\n  }\n\n  this.cmdFn = cmdFn;\n\n  this.preConditions = [];\n  this.preLoadConditions = [];\n}\n\nutil.inherits(Command, Definition);\n\n_.extend(Command.prototype, {\n\n  /**\n   * Inject the aggregate module.\n   * @param {Aggregate} aggregate The context module to be injected.\n   */\n  defineAggregate: function (aggregate) {\n    if (!aggregate || !_.isObject(aggregate)) {\n      var err = new Error('Please inject a valid aggregate object!');\n      debug(err);\n      throw err;\n    }\n\n    this.aggregate = aggregate;\n  },\n\n  /**\n   * Injects the pre-condition function.\n   * @param {Function} preCond The pre-condition function that should be injected\n   */\n  addPreCondition: function (preCond) {\n    if (!preCond || !_.isObject(preCond)) {\n      var err = new Error('Please inject a valid preCondition object!');\n      debug(err);\n      throw err;\n    }\n\n    if (!preCond.payload && preCond.payload !== '') {\n      preCond.payload = this.aggregate.defaultPreConditionPayload;\n    }\n\n    if (this.preConditions.indexOf(preCond) < 0) {\n      preCond.defineAggregate(this.aggregate);\n      this.preConditions.push(preCond);\n      this.preConditions = _.sortBy(this.preConditions, function(pc) {\n        return pc.priority;\n      });\n    }\n  },\n\n  /**\n   * Injects the pre-load-condition function.\n   * @param {Function} preLoadCond The pre-load-condition function that should be injected\n   */\n  addPreLoadCondition: function (preLoadCond) {\n    if (!preLoadCond || !_.isObject(preLoadCond)) {\n      var err = new Error('Please inject a valid preCondition object!');\n      debug(err);\n      throw err;\n    }\n\n    if (!preLoadCond.payload) {\n      preLoadCond.payload = this.aggregate.defaultPreLoadConditionPayload;\n    }\n\n    if (this.preLoadConditions.indexOf(preLoadCond) < 0) {\n      preLoadCond.defineAggregate(this.aggregate);\n      this.preLoadConditions.push(preLoadCond);\n      this.preLoadConditions = _.sortBy(this.preLoadConditions, function(pc) {\n        return pc.priority;\n      });\n    }\n  },\n\n  /**\n   * Injects the validator function.\n   * @param {Function} validator The validator function that should be injected\n   */\n  defineValidation: function (validator) {\n    if (!_.isFunction(validator)) {\n      var err = new Error('Please pass in a function');\n      debug(err);\n      throw err;\n    }\n    this.validator = validator;\n  },\n\n  /**\n   * Validates the requested command.\n   * @param {Object} cmd The command object\n   * @returns {ValidationError}\n   */\n  validate: function (cmd) {\n    if (!this.validator) {\n      debug('no validation rule for ' + this.name);\n      return;\n    }\n    return this.validator(cmd);\n  },\n\n  /**\n   * Checks for pre-load conditions\n   * @param {Object}         cmd            The command object.\n   * @param {Function}       callback       The function, that will be called when this action is completed.\n   *                                        `function(err){}`\n   */\n  checkPreLoadConditions: function (cmd, callback) {\n    if (this.preLoadConditions.length === 0) {\n      debug('no pre-load-condition for ' + this.name);\n      return callback(null);\n    }\n\n    async.eachSeries(this.preLoadConditions, function (preLoadCondition, callback) {\n      preLoadCondition.check(cmd, callback);\n    }, callback);\n  },\n\n  /**\n   * Checks for pre-conditions\n   * @param {Object}         cmd            The command object.\n   * @param {AggregateModel} aggregateModel The aggregate object.\n   * @param {Function}       callback       The function, that will be called when this action is completed.\n   *                                        `function(err){}`\n   */\n  checkPreConditions: function (cmd, aggregateModel, callback) {\n    if (this.existing === true && aggregateModel.get('_revision') === 0) {\n      var err = new BusinessRuleError('This command only wants to be handled, if aggregate already existing!', {\n        type: 'AggregateNotExisting',\n        aggregateId: aggregateModel.id,\n        aggregateRevision: aggregateModel.get('_revision')\n      });\n      debug(err);\n      return callback(err);\n    }\n\n    if (this.existing === false && aggregateModel.get('_revision') !== 0) {\n      var err = new BusinessRuleError('This command only wants to be handled, if aggregate not existing!', {\n        type: 'AggregateAlreadyExisting',\n        aggregateId: aggregateModel.id,\n        aggregateRevision: aggregateModel.get('_revision')\n      });\n      debug(err);\n      return callback(err);\n    }\n\n    if (this.preConditions.length === 0) {\n      debug('no pre-condition for ' + this.name);\n      return callback(null);\n    }\n\n    async.eachSeries(this.preConditions, function (preCondition, callback) {\n      preCondition.check(cmd, aggregateModel, callback);\n    }, callback);\n  },\n\n  /**\n   * Get infos to load correct stream.\n   * @param {Object} cmd The command object.\n   * @returns {Array}\n   */\n  getLoadInfo: function (cmd) {\n    var aggregateId = dotty.get(cmd, this.definitions.command.aggregateId);\n    var aggregateName = this.aggregate.name;\n    var contextName = this.aggregate.context.name;\n\n    var toLoad = [{\n      context: contextName,\n      aggregate: aggregateName,\n      aggregateId: aggregateId\n    }];\n\n    if (_.isFunction(this.getStreamsInfo)) {\n      toLoad = this.getStreamsInfo(cmd);\n      if (!_.isArray(toLoad)) {\n        toLoad = [toLoad];\n      }\n      toLoad.forEach(function (l) {\n        l.aggregateId = l.aggregateId || aggregateId;\n      });\n    }\n\n    if (toLoad[0].context !== contextName || toLoad[0].aggregate !== aggregateName) {\n      throw new Error('First stream to load has to be the new one!');\n    }\n\n    return toLoad;\n  },\n\n  /**\n   * Handles the passed command\n   * @param {Object}         cmd            The command object.\n   * @param {AggregateModel} aggregateModel The aggregate object.\n   */\n  handle: function (cmd, aggregateModel) {\n    if (!this.payload || this.payload === '') {\n      this.cmdFn(_.cloneDeep(cmd), aggregateModel);\n      return;\n    }\n\n    var payload = dotty.get(cmd, this.payload);\n    this.cmdFn(_.cloneDeep(payload), aggregateModel);\n  },\n\n  /**\n   * Defines which event streams should be loaded before handling this event.\n   * @param {Function} fn Function containing the algorithm. Should return an array of infos.\n   *                      `function(cmd){}`\n   */\n  defineEventStreamsToLoad: function (fn) {\n    if (!_.isFunction(fn)) {\n      throw new Error('Please pass in a function');\n    }\n\n    this.getStreamsInfo = fn;\n    return this;\n  }\n\n});\n\nmodule.exports = Command;\n","/home/travis/build/npmtest/node-npmtest-cqrs-domain/node_modules/cqrs-domain/lib/errors/businessRuleError.js":"'use strict';\n\n// Grab the util module that's bundled with Node\nvar util = require('util');\n\n// Create a new custom Error constructor\nfunction BusinessRuleError(msg, more) {\n  // Pass the constructor to V8's\n  // captureStackTrace to clean up the output\n  Error.captureStackTrace(this, BusinessRuleError);\n\n  // If defined, store a custom error message\n  if (msg) {\n    this.message = msg;\n  }\n\n  // If defined, store more infos\n  if (more) {\n    this.more = more;\n  }\n}\n\n// Extend our custom Error from Error\nutil.inherits(BusinessRuleError, Error);\n\n// Give our custom error a name property. Helpful for logging the error later.\nBusinessRuleError.prototype.name = BusinessRuleError.name;\n\nmodule.exports = BusinessRuleError;\n","/home/travis/build/npmtest/node-npmtest-cqrs-domain/node_modules/cqrs-domain/lib/definitions/event.js":"'use strict';\n\nvar Definition = require('../definitionBase'),\n  util = require('util'),\n  _ = require('lodash'),\n  dotty = require('dotty'),\n  debug = require('debug')('domain:event');\n\n/**\n * Event constructor\n * @param {Object}   meta  Meta infos like: { name: 'name', version: 1, payload: 'some.path' }\n * @param {Function} evtFn Fuction handle\n *                         `function(evtData, aggregateModel){}`\n * @constructor\n */\nfunction Event (meta, evtFn) {\n  Definition.call(this, meta);\n\n  meta = meta || {};\n\n  if (evtFn && !_.isFunction(evtFn)) {\n    var err = new Error('Event function not injected!');\n    debug(err);\n    throw err;\n  }\n\n  this.version = meta.version || 0;\n  this.payload = meta.payload === '' ? meta.payload : (meta.payload || null);\n\n  this.evtFn = evtFn;\n}\n\nutil.inherits(Event, Definition);\n\n_.extend(Event.prototype, {\n\n  /**\n   * Apply an event.\n   * @param {Object}         evt            The event object.\n   * @param {AggregateModel} aggregateModel The aggregate object.\n   */\n  apply: function (evt, aggregateModel) {\n    if (!this.evtFn) {\n      return;\n    }\n\n    if (!this.payload || this.payload === '') {\n      this.evtFn(evt, aggregateModel);\n      return;\n    }\n\n    var payload = dotty.get(evt, this.payload);\n    this.evtFn(payload, aggregateModel);\n  }\n\n});\n\nmodule.exports = Event;\n","/home/travis/build/npmtest/node-npmtest-cqrs-domain/node_modules/cqrs-domain/lib/definitions/businessRule.js":"'use strict';\n\nvar Definition = require('../definitionBase'),\n  util = require('util'),\n  _ = require('lodash'),\n  debug = require('debug')('domain:businessRule'),\n  BusinessRuleError = require('../errors/businessRuleError');\n\n/**\n * BusinessRule constructor\n * @param {Object}   meta           Meta infos like: { name: 'name', priority: 1, description: 'bla bla' }\n * @param {Function} businessRuleFn Function handle\n *                                  `function(changed, previous, events, command, callback){}`\n * @constructor\n */\nfunction BusinessRule (meta, businessRuleFn) {\n  Definition.call(this, meta);\n\n  meta = meta || {};\n\n  if (!businessRuleFn || !_.isFunction(businessRuleFn)) {\n    var err = new Error('Business rule function not injected!');\n    debug(err);\n    throw err;\n  }\n\n  this.description = meta.description;\n  this.priority = meta.priority || Infinity;\n\n  this.businessRuleFn = businessRuleFn;\n}\n\nutil.inherits(BusinessRule, Definition);\n\n_.extend(BusinessRule.prototype, {\n\n  /**\n   * Inject the aggregate module.\n   * @param {Aggregate} aggregate The context module to be injected.\n   */\n  defineAggregate: function (aggregate) {\n    if (!aggregate || !_.isObject(aggregate)) {\n      var err = new Error('Please inject a valid aggregate object!');\n      debug(err);\n      throw err;\n    }\n\n    this.aggregate = aggregate;\n  },\n\n  /**\n   * Checks this business rule.\n   * @param {Object}   changed  The new aggregate values.\n   * @param {Object}   previous The previous aggregate values.\n   * @param {Array}    events   All new generated events.\n   * @param {Object}   command  The command that was handled.\n   * @param {Function} callback The function, that will be called when this action is completed.\n   *                            `function(err){}`\n   */\n  check: function (changed, previous, events, command, callback) {\n\n    var self = this;\n    var callbacked = false;\n\n    function handleError (err) {\n      debug(err);\n\n      if (_.isString(err)) {\n        if (_.isEmpty(err)) {\n          err = self.description;\n        }\n        err = new BusinessRuleError(err);\n      } else if (err instanceof BusinessRuleError) {\n        // do nothing\n      } else {\n        err = new BusinessRuleError(err.message || self.description);\n      }\n\n      callbacked = true;\n      callback(err);\n    }\n\n    try {\n      if (this.businessRuleFn.length === 5) {\n        this.businessRuleFn(changed, previous, events, command, function (err) {\n          if (err) {\n            return handleError(err);\n          }\n          callbacked = true;\n          callback(null);\n        });\n      } else {\n        var err = this.businessRuleFn(changed, previous, events, command);\n        if (err) {\n          return handleError(err);\n        }\n        callbacked = true;\n        callback(null);\n      }\n    } catch (err) {\n      if (!callbacked) {\n        return handleError(err);\n      }\n      throw err;\n    }\n  }\n\n});\n\nmodule.exports = BusinessRule;\n","/home/travis/build/npmtest/node-npmtest-cqrs-domain/node_modules/cqrs-domain/lib/definitions/preCondition.js":"'use strict';\n\nvar Definition = require('../definitionBase'),\n  util = require('util'),\n  _ = require('lodash'),\n  dotty = require('dotty'),\n  debug = require('debug')('domain:preCondition'),\n  BusinessRuleError = require('../errors/businessRuleError');\n\n/**\n * PreCondition constructor\n * @param {Object}   meta           Meta infos like: { name: 'name', version: 1, priority: 1, payload: 'some.path', description: 'bla bla' }\n * @param {Function} preConditionFn Function handle\n *                                  `function(command, aggData, callback){}`\n * @constructor\n */\nfunction PreCondition (meta, preConditionFn) {\n  Definition.call(this, meta);\n\n  meta = meta || {};\n\n  if (!preConditionFn || !_.isFunction(preConditionFn)) {\n    var err = new Error('Pre-condition function not injected!');\n    debug(err);\n    throw err;\n  }\n\n  this.description = meta.description;\n  this.version = meta.version || 0;\n  this.payload = meta.payload === '' ? meta.payload : (meta.payload || null);\n  this.priority = meta.priority || Infinity;\n\n  this.preConditionFn = preConditionFn;\n}\n\nutil.inherits(PreCondition, Definition);\n\n_.extend(PreCondition.prototype, {\n\n  /**\n   * Inject the aggregate module.\n   * @param {Aggregate} aggregate The context module to be injected.\n   */\n  defineAggregate: function (aggregate) {\n    if (!aggregate || !_.isObject(aggregate)) {\n      var err = new Error('Please inject a valid aggregate object!');\n      debug(err);\n      throw err;\n    }\n\n    this.aggregate = aggregate;\n  },\n\n  /**\n   * Checks this business rule.\n   * @param {Object}   command  The command that was handled.\n   * @param {Object}   aggData  The aggregate values.\n   * @param {Function} callback The function, that will be called when this action is completed.\n   *                            `function(err){}`\n   */\n  check: function (command, aggData, callback) {\n\n    var self = this;\n    var callbacked = false;\n\n    function handleError (err) {\n      debug(err);\n\n      if (_.isString(err)) {\n        if (_.isEmpty(err)) {\n          err = self.description;\n        }\n        err = new BusinessRuleError(err);\n      } else if (err instanceof BusinessRuleError) {\n        // do nothing\n      } else {\n        err = new BusinessRuleError(err.message || self.description);\n      }\n\n      callbacked = true;\n      callback(err);\n    }\n\n    var payload;\n    if (!this.payload || this.payload === '') {\n      payload = command;\n    } else {\n      payload = dotty.get(command, this.payload);\n    }\n\n    try {\n      if (this.preConditionFn.length === 3) {\n        this.preConditionFn(_.cloneDeep(payload), aggData, function (err) {\n          if (err) {\n            return handleError(err);\n          }\n          callbacked = true;\n          callback(null);\n        });\n      } else {\n        var err = this.preConditionFn(_.cloneDeep(payload), aggData);\n        if (err) {\n          return handleError(err);\n        }\n        callbacked = true;\n        callback(null);\n      }\n    } catch (err) {\n      if (!callbacked) {\n        return handleError(err);\n      }\n      throw err;\n    }\n  }\n\n});\n\nmodule.exports = PreCondition;\n","/home/travis/build/npmtest/node-npmtest-cqrs-domain/node_modules/cqrs-domain/lib/definitions/preLoadCondition.js":"'use strict';\n\nvar Definition = require('../definitionBase'),\n  util = require('util'),\n  _ = require('lodash'),\n  dotty = require('dotty'),\n  debug = require('debug')('domain:preLoadCondition'),\n  BusinessRuleError = require('../errors/businessRuleError');\n\n/**\n * PreLoadCondition constructor\n * @param {Object}   meta  Meta infos like: { name: 'name', version: 1, priority: 1, payload: 'some.path', description: 'bla bla' }\n * @param {Function} preLoadConditionFn Function handle\n *                                  `function(command, aggData, callback){}`\n * @constructor\n */\nfunction PreLoadCondition (meta, preLoadConditionFn) {\n  Definition.call(this, meta);\n\n  meta = meta || {};\n\n  if (!preLoadConditionFn || !_.isFunction(preLoadConditionFn)) {\n    var err = new Error('Pre-load-condition function not injected!');\n    debug(err);\n    throw err;\n  }\n\n  this.description = meta.description;\n  this.version = meta.version || 0;\n  this.payload = meta.payload || null;\n  this.priority = meta.priority || Infinity;\n\n  this.preLoadConditionFn = preLoadConditionFn;\n}\n\nutil.inherits(PreLoadCondition, Definition);\n\n_.extend(PreLoadCondition.prototype, {\n\n  /**\n   * Inject the aggregate module.\n   * @param {Aggregate} aggregate The context module to be injected.\n   */\n  defineAggregate: function (aggregate) {\n    if (!aggregate || !_.isObject(aggregate)) {\n      var err = new Error('Please inject a valid aggregate object!');\n      debug(err);\n      throw err;\n    }\n\n    this.aggregate = aggregate;\n  },\n\n  /**\n   * Checks this business rule.\n   * @param {Object}   command  The command that was handled.\n   * @param {Object}   aggData  The aggregate values.\n   * @param {Function} callback The function, that will be called when this action is completed.\n   *                            `function(err){}`\n   */\n  check: function (command, callback) {\n\n    var self = this;\n    var callbacked = false;\n\n    function handleError (err) {\n      debug(err);\n\n      if (_.isString(err)) {\n        if (_.isEmpty(err)) {\n          err = self.description;\n        }\n        err = new BusinessRuleError(err);\n      } else if (err instanceof BusinessRuleError) {\n        // do nothing\n      } else {\n        err = new BusinessRuleError(err.message || self.description);\n      }\n\n      callbacked = true;\n      callback(err);\n    }\n\n    var payload;\n    if (!this.payload || this.payload === '') {\n      payload = command;\n    } else {\n      payload = dotty.get(command, this.payload);\n    }\n\n    try {\n      if (this.preLoadConditionFn.length === 2) {\n        this.preLoadConditionFn(_.cloneDeep(payload), function (err) {\n          if (err) {\n            return handleError(err);\n          }\n          callbacked = true;\n          callback(null);\n        });\n      } else {\n        var err = this.preLoadConditionFn(_.cloneDeep(payload));\n        if (err) {\n          return handleError(err);\n        }\n        callbacked = true;\n        callback(null);\n      }\n    } catch (err) {\n      if (!callbacked) {\n        return handleError(err);\n      }\n      throw err;\n    }\n  }\n\n});\n\nmodule.exports = PreLoadCondition;\n","/home/travis/build/npmtest/node-npmtest-cqrs-domain/node_modules/cqrs-domain/lib/definitions/commandHandler.js":"'use strict';\n\nvar DefaultCommandHandler = require('../defaultCommandHandler'),\n  util = require('util'),\n  _ = require('lodash'),\n  dotty = require('dotty'),\n  debug = require('debug')('domain:commandHandler');\n\n/**\n * CommandHandler constructor\n * @param {Object}   meta      Meta infos like: { name: 'name', version: 1 }\n * @param {Function} cmdHndlFn Function handle\n *                             `function(aggId, cmd, commandHandler, callback){}`\n * @constructor\n */\nfunction CommandHandler (meta, cmdHndlFn) {\n  DefaultCommandHandler.call(this, meta);\n\n  console.log('Is your use case not solvable without a custom command handling? Sagas? Micro-Services?');\n\n  meta = meta || {};\n\n  this.version = meta.version || 0;\n\n  if (!cmdHndlFn || !_.isFunction(cmdHndlFn)) {\n    var err = new Error('CommandHandler function not injected!');\n    debug(err);\n    throw err;\n  }\n\n  this.cmdHndlFn = cmdHndlFn;\n}\n\nutil.inherits(CommandHandler, DefaultCommandHandler);\n\n_.extend(CommandHandler.prototype, {\n\n  /**\n   * Handles the passed command\n   * @param {Object}   cmd      The passed command\n   * @param {Function} callback The function, that will be called when this action is completed.\n   *                            `function(err, evts){}`\n   */\n  handle: function (cmd, callback) {\n    debug('called a custom command handler');\n    console.log('Is your use case not solvable without a custom command handling? Sagas? Micro-Services?');\n\n    var self = this;\n\n    function _handle (aggId) {\n      var concatenatedId = self.getConcatenatedId(aggId, cmd);\n\n      var isFirst = !self.getNextCommandInQueue(concatenatedId);\n\n      self.queueCommand(concatenatedId, cmd, callback);\n\n      if (!isFirst) {\n        return;\n      }\n\n      (function handleNext (aggregateId, c) {\n        var concId = self.getConcatenatedId(aggregateId, c);\n        var cmdEntry = self.getNextCommandInQueue(concId);\n        if (cmdEntry) {\n          if (cmdEntry.callback.length > 2) {\n            self.cmdHndlFn(aggregateId, cmdEntry.command, self, function (err, evts, aggData, meta) {\n              self.removeCommandFromQueue(concId, cmdEntry.command);\n              handleNext(aggregateId, cmdEntry.command);\n              cmdEntry.callback(err, evts, aggData, meta);\n            });\n            return;\n          }\n          self.cmdHndlFn(aggregateId, cmdEntry.command, self, function (err, evts) {\n            self.removeCommandFromQueue(concId, cmdEntry.command);\n            handleNext(aggregateId, cmdEntry.command);\n            cmdEntry.callback(err, evts);\n          });\n        }\n      })(aggId, cmd);\n    }\n\n    if (dotty.exists(cmd, this.definitions.command.aggregateId)) {\n      return _handle(dotty.get(cmd, this.definitions.command.aggregateId));\n    }\n\n    debug('no aggregateId in command, so generate a new one');\n\n    this.getNewAggregateId(function (err, id) {\n      if (err) {\n        debug(err);\n        return callback(err);\n      }\n\n      return _handle(id);\n    });\n  }\n\n});\n\nmodule.exports = CommandHandler;\n","/home/travis/build/npmtest/node-npmtest-cqrs-domain/node_modules/cqrs-domain/lib/structure/treeExtender.js":"'use strict';\n\nvar debug = require('debug')('domain:treeExtender'),\n  _ = require('lodash'),\n  Context = require('../definitions/context');\n\nfunction getCommandHandler (ctx, query) {\n  var aggr;\n  if (query.aggregate) {\n    aggr = ctx.getAggregate(query.aggregate);\n  } else {\n    aggr = ctx.getAggregateForCommand(query.name, query.version);\n  }\n\n  if (!aggr) {\n    return null;\n  }\n\n  return aggr.getCommandHandler(query.name, query.version);\n}\n\n// function getCommandHandlerByOldTarget (ctx, query) {\n//   var aggr = ctx.getAggregateForCommandByOldTarget(query);\n//\n//   if (!aggr) {\n//     return null;\n//   }\n//\n//   return aggr.getCommandHandler(query.name, query.version);\n// }\n\nmodule.exports = function (tree) {\n\n  if (!tree || _.isEmpty(tree)) {\n    debug('no tree injected');\n  }\n\n  return {\n\n    getInfo: function () {\n      if (!tree || _.isEmpty(tree)) {\n        debug('no tree injected');\n        return null;\n      }\n\n      var ctxs = this.getContexts();\n\n      var info = {\n        contexts: []\n      };\n\n      ctxs.forEach(function (ctx) {\n        var c = { name: ctx.name, aggregates: [] };\n\n        ctx.aggregates.forEach(function (aggr) {\n          var a = { name: aggr.name, version: aggr.version, commands: [], events: [], businessRules: [] };\n\n          aggr.commands.forEach(function (command) {\n            var cmd = { name: command.name, version: command.version, preConditions: [], preLoadConditions: [] };\n            // if (command.source && command.source.aggregate) {\n            //   cmd.source = command.source;\n            // }\n            command.preConditions.forEach(function (pc) {\n              var n = pc.name.join(', ');\n              cmd.preConditions.push({ name: n, description: pc.description, priority: pc.priority });\n            });\n\n            command.preLoadConditions.forEach(function (pc) {\n              var n = pc.name.join(', ');\n              cmd.preLoadConditions.push({ name: n, description: pc.description, priority: pc.priority });\n            });\n            \n            a.commands.push(cmd);\n          });\n\n          aggr.events.forEach(function (event) {\n            a.events.push({ name: event.name, version: event.version });\n          });\n\n          aggr.businessRules.forEach(function (businessRule) {\n            a.businessRules.push({ name: businessRule.name, description: businessRule.description, priority: businessRule.priority });\n          });\n\n          c.aggregates.push(a);\n        });\n\n        info.contexts.push(c);\n      });\n\n      return info;\n    },\n\n    getContexts: function () {\n      if (!tree || _.isEmpty(tree)) {\n        debug('no tree injected');\n        return null;\n      }\n\n      var ctxs = [];\n      for (var c in tree) {\n        var ctx = tree[c];\n        if (ctx instanceof Context) {\n          ctxs.push(ctx);\n        }\n      }\n      return ctxs;\n    },\n\n    getContext: function (name) {\n      if (!tree || _.isEmpty(tree)) {\n        debug('no tree injected');\n        return null;\n      }\n\n      var ctx = tree[name];\n      if (ctx instanceof Context) {\n        return ctx;\n      }\n      return null;\n    },\n\n    getCommandHandler: function (query) {\n      if (!tree || _.isEmpty(tree)) {\n        debug('no tree injected');\n        return null;\n      }\n\n      var ctx;\n      if (query.context) {\n        ctx = this.getContext(query.context);\n        if (!ctx) {\n          debug('no context found with name ' + query.context);\n          return null;\n        }\n        return getCommandHandler(ctx, query);\n      } else {\n        var ctxs = this.getContexts();\n        for (var c in ctxs) {\n          ctx = ctxs[c];\n          var handler = getCommandHandler(ctx, query);\n          if (handler) {\n            return handler;\n          }\n        }\n      }\n      return null;\n    },\n\n    // getCommandHandlerByOldTarget: function (query) {\n    //   if (!tree || _.isEmpty(tree)) {\n    //     debug('no tree injected');\n    //     return null;\n    //   }\n    //\n    //   var ctx;\n    //   var ctxs = this.getContexts();\n    //   for (var c in ctxs) {\n    //     ctx = ctxs[c];\n    //     var handler = getCommandHandlerByOldTarget(ctx, query);\n    //     if (handler) {\n    //       return handler;\n    //     }\n    //   }\n    //   return null;\n    // },\n\n    defineOptions: function (options) {\n      if (!tree || _.isEmpty(tree)) {\n        debug('no tree injected');\n        return this;\n      }\n\n      this.getContexts().forEach(function (ctx) {\n        ctx.defineOptions(options);\n\n        ctx.getAggregates().forEach(function (aggr) {\n          aggr.defineOptions(options);\n\n          if (aggr.defaultCommandHandler) {\n            aggr.defaultCommandHandler.defineOptions(options);\n          }\n\n          aggr.getCommands().forEach(function (cmd) {\n            cmd.defineOptions(options);\n\n            if (cmd.preCondition) {\n              cmd.preCondition.defineOptions(options);\n            }\n\n            if (cmd.preLoadCondition) {\n              cmd.preLoadCondition.defineOptions(options);\n            }\n          });\n\n          aggr.getEvents().forEach(function (evt) {\n            evt.defineOptions(options);\n          });\n\n          aggr.getCommandHandlers().forEach(function (cmdHndl) {\n            cmdHndl.defineOptions(options);\n          });\n\n          aggr.getBusinessRules().forEach(function (buRu) {\n            buRu.defineOptions(options);\n          });\n        });\n      });\n      return this;\n    },\n\n    defineCommand: function (definition) {\n      if (!tree || _.isEmpty(tree)) {\n        debug('no tree injected');\n        return this;\n      }\n\n      this.getContexts().forEach(function (ctx) {\n        ctx.defineCommand(definition);\n\n        ctx.getAggregates().forEach(function (aggr) {\n          aggr.defineCommand(definition);\n\n          if (aggr.defaultCommandHandler) {\n            aggr.defaultCommandHandler.defineCommand(definition);\n          }\n\n          aggr.getCommands().forEach(function (cmd) {\n            cmd.defineCommand(definition);\n          });\n\n          aggr.getEvents().forEach(function (evt) {\n            evt.defineCommand(definition);\n          });\n\n          aggr.getCommandHandlers().forEach(function (cmdHndl) {\n            cmdHndl.defineCommand(definition);\n          });\n\n          aggr.getBusinessRules().forEach(function (buRu) {\n            buRu.defineCommand(definition);\n          });\n        });\n      });\n      return this;\n    },\n\n    defineEvent: function (definition) {\n      if (!tree || _.isEmpty(tree)) {\n        debug('no tree injected');\n        return this;\n      }\n\n      this.getContexts().forEach(function (ctx) {\n        ctx.defineEvent(definition);\n\n        ctx.getAggregates().forEach(function (aggr) {\n          aggr.defineEvent(definition);\n\n          if (aggr.defaultCommandHandler) {\n            aggr.defaultCommandHandler.defineEvent(definition);\n          }\n\n          aggr.getCommands().forEach(function (cmd) {\n            cmd.defineEvent(definition);\n\n            if (cmd.preCondition) {\n              cmd.preCondition.defineEvent(definition);\n            }\n\n            if (cmd.preLoadCondition) {\n              cmd.preLoadCondition.defineEvent(definition);\n            }\n          });\n\n          aggr.getEvents().forEach(function (evt) {\n            evt.defineEvent(definition);\n          });\n\n          aggr.getCommandHandlers().forEach(function (cmdHndl) {\n            cmdHndl.defineEvent(definition);\n          });\n\n          aggr.getBusinessRules().forEach(function (buRu) {\n            buRu.defineEvent(definition);\n          });\n        });\n      });\n      return this;\n    },\n\n    useEventStore: function (eventStore) {\n      if (!tree || _.isEmpty(tree)) {\n        debug('no tree injected');\n        return this;\n      }\n\n      this.getContexts().forEach(function (ctx) {\n        ctx.getAggregates().forEach(function (aggr) {\n          if (aggr.defaultCommandHandler) {\n            aggr.defaultCommandHandler.useEventStore(eventStore);\n          }\n          aggr.getCommandHandlers().forEach(function (cmdHndl) {\n            cmdHndl.useEventStore(eventStore);\n          });\n        });\n      });\n      return this;\n    },\n\n    useAggregateLock: function (aggregateLock) {\n      if (!tree || _.isEmpty(tree)) {\n        debug('no tree injected');\n        return this;\n      }\n\n      this.getContexts().forEach(function (ctx) {\n        ctx.getAggregates().forEach(function (aggr) {\n          if (aggr.defaultCommandHandler) {\n            aggr.defaultCommandHandler.useAggregateLock(aggregateLock);\n          }\n          aggr.getCommandHandlers().forEach(function (cmdHndl) {\n            cmdHndl.useAggregateLock(aggregateLock);\n          });\n        });\n      });\n      return this;\n    },\n\n    idGenerator: function (getNewId) {\n      if (!getNewId || !_.isFunction(getNewId)) {\n        var err = new Error('Please pass a valid function!');\n        debug(err);\n        throw err;\n      }\n\n      if (!tree || _.isEmpty(tree)) {\n        debug('no tree injected');\n        return this;\n      }\n\n      this.getContexts().forEach(function (ctx) {\n        ctx.getAggregates().forEach(function (aggr) {\n          aggr.idGenerator(getNewId);\n        });\n      });\n      return this;\n    },\n\n    aggregateIdGenerator: function (getNewId) {\n      if (!getNewId || !_.isFunction(getNewId)) {\n        var err = new Error('Please pass a valid function!');\n        debug(err);\n        throw err;\n      }\n\n      if (!tree || _.isEmpty(tree)) {\n        debug('no tree injected');\n        return this;\n      }\n\n      this.getContexts().forEach(function (ctx) {\n        ctx.getAggregates().forEach(function (aggr) {\n          if (aggr.defaultCommandHandler) {\n            aggr.defaultCommandHandler.aggregateIdGenerator(getNewId);\n          }\n          aggr.getCommandHandlers().forEach(function (cmdHndl) {\n            cmdHndl.aggregateIdGenerator(getNewId);\n          });\n        });\n      });\n      return this;\n    }\n\n  };\n\n};\n","/home/travis/build/npmtest/node-npmtest-cqrs-domain/node_modules/cqrs-domain/lib/errors/validationError.js":"'use strict';\n\n// Grab the util module that's bundled with Node\nvar util = require('util');\n\n// Create a new custom Error constructor\nfunction ValidationError(msg, more) {\n  // Pass the constructor to V8's\n  // captureStackTrace to clean up the output\n  Error.captureStackTrace(this, ValidationError);\n\n  // If defined, store a custom error message\n  if (msg) {\n    this.message = msg;\n  }\n\n  // If defined, store more infos\n  if (more) {\n    this.more = more;\n  }\n}\n\n// Extend our custom Error from Error\nutil.inherits(ValidationError, Error);\n\n// Give our custom error a name property. Helpful for logging the error later.\nValidationError.prototype.name = ValidationError.name;\n\nmodule.exports = ValidationError;\n","/home/travis/build/npmtest/node-npmtest-cqrs-domain/node_modules/cqrs-domain/lib/errors/duplicateCommandError.js":"'use strict';\n\n// Grab the util module that's bundled with Node\nvar util = require('util');\n\n// Create a new custom Error constructor\nfunction DuplicateCommandError(msg, more) {\n  // Pass the constructor to V8's\n  // captureStackTrace to clean up the output\n  Error.captureStackTrace(this, DuplicateCommandError);\n\n  // If defined, store a custom error message\n  if (msg) {\n    this.message = msg;\n  }\n\n  // If defined, store more infos\n  if (more) {\n    this.more = more;\n  }\n}\n\n// Extend our custom Error from Error\nutil.inherits(DuplicateCommandError, Error);\n\n// Give our custom error a name property. Helpful for logging the error later.\nDuplicateCommandError.prototype.name = DuplicateCommandError.name;\n\nmodule.exports = DuplicateCommandError;\n","/home/travis/build/npmtest/node-npmtest-cqrs-domain/node_modules/cqrs-domain/lib/commandDispatcher.js":"'use strict';\n\nvar debug = require('debug')('domain:commandDispatcher'),\n  _ = require('lodash'),\n  dotty = require('dotty'),\n  DuplicateCommandError = require('./errors/duplicateCommandError');\n\n/**\n * CommandDispatcher constructor\n * @param {Object} tree          The tree object.\n * @param {Object} definition    The definition object.\n * @param {Object} commandBunper The commandBumper object. [optional]\n * @constructor\n */\nfunction CommandDispatcher (tree, definition, commandBumper) {\n  if (!tree || !_.isObject(tree) || !_.isFunction(tree.getCommandHandler)) {\n    var err = new Error('Please pass a valid tree!');\n    debug(err);\n    throw err;\n  }\n\n  if (!definition || !_.isObject(definition)) {\n    var err = new Error('Please pass a valid command definition!');\n    debug(err);\n    throw err;\n  }\n\n  this.tree = tree;\n  this.definition = definition;\n\n  this.commandBumper = commandBumper;\n}\n\nCommandDispatcher.prototype = {\n\n  /**\n   * Returns the target information of this command.\n   * @param {Object} cmd The passed command.\n   * @returns {{name: 'commandName', aggregateId: 'aggregateId', version: 0, aggregate: 'aggregateName', context: 'contextName'}}\n   */\n  getTargetInformation: function (cmd) {\n    if (!cmd || !_.isObject(cmd)) {\n      var err = new Error('Please pass a valid command!');\n      debug(err);\n      throw err;\n    }\n\n    var aggregateId = null;\n    if (dotty.exists(cmd, this.definition.aggregateId)) {\n      aggregateId = dotty.get(cmd, this.definition.aggregateId);\n    } else {\n      debug('no aggregateId found, seems to be for a new aggregate');\n    }\n\n    var name = dotty.get(cmd, this.definition.name);\n\n    var version = 0;\n    if (dotty.exists(cmd, this.definition.version)) {\n      version = dotty.get(cmd, this.definition.version);\n    } else {\n      debug('no version found, handling as version: 0');\n    }\n\n    var aggregate = null;\n    if (dotty.exists(cmd, this.definition.aggregate)) {\n      aggregate = dotty.get(cmd, this.definition.aggregate);\n    } else {\n      debug('no aggregate found, will lookup in all aggregates');\n    }\n\n    var context = null;\n    if (dotty.exists(cmd, this.definition.context)) {\n      context = dotty.get(cmd, this.definition.context);\n    } else {\n      debug('no aggregateName found, will lookup in all contexts');\n    }\n\n    return {\n      name: name,\n      aggregateId: aggregateId,\n      version: version,\n      aggregate: aggregate,\n      context: context\n    };\n  },\n\n  /**\n   * Dispatches a command.\n   * @param {Object}   cmd      The passed command.\n   * @param {Function} callback The function, that will be called when this action is completed.\n   *                            `function(err, evts){}`\n   */\n  dispatch: function (cmd, callback) {\n    if (!cmd || !_.isObject(cmd)) {\n      var err = new Error('Please pass a valid command!');\n      debug(err);\n      throw err;\n    }\n\n    if (!callback || !_.isFunction(callback)) {\n      var err = new Error('Please pass a valid callback!');\n      debug(err);\n      throw err;\n    }\n\n    var target = this.getTargetInformation(cmd);\n\n    var commandHandler = this.tree.getCommandHandler(target);\n\n    // if (!commandHandler) {\n    //   commandHandler = this.tree.getCommandHandlerByOldTarget(target);\n    // }\n\n    if (!commandHandler) {\n      var err = new Error('No command handler found for ' + target.name);\n      debug(err);\n      return callback(err);\n    }\n\n    if (!this.commandBumper) {\n      return commandHandler.handle(cmd, callback);\n    }\n\n    var key = target.context + target.aggregate + target.aggregateId + dotty.get(cmd, this.definition.id);\n\n    this.commandBumper.add(key, function (err, added) {\n      if (err) {\n        return callback(err);\n      }\n\n      if (!added) {\n        return callback(new DuplicateCommandError('Command already seen!'));\n      }\n\n      commandHandler.handle(cmd, callback);\n    });\n  }\n\n};\n\nmodule.exports = CommandDispatcher;\n","/home/travis/build/npmtest/node-npmtest-cqrs-domain/node_modules/cqrs-domain/lib/validator.js":"'use strict';\n\nvar debug = require('debug')('domain:validator'),\n  _ = require('lodash'),\n  tv4Module = require('tv4'),\n  ValidationError = require('./errors/validationError');\n\n/**\n * Returns a validator function.\n * @param {Object} options The options object.\n * @param {Object} schema  The schema object.\n * @returns {Function}\n */\nfunction getValidator (options, schema) {\n  options = options || {};\n  options.schemas = options.schemas || {};\n  options.formats = options.formats || {};\n\n  if (!schema || !_.isObject(schema)) {\n    var err = new Error('Please pass a valid schema!');\n    debug(err);\n    throw err;\n  }\n\n  var tv4 = tv4Module.freshApi();\n\n  _.each(options.schemas, function (v, k) {\n    tv4.addSchema(k, v);\n  });\n\n  tv4.addFormat(options.formats);\n\n  return function (data) {\n    var validation = tv4.validateMultiple(data, schema);\n\n    if (validation.missing.length > 0) {\n      var missingString = validation.missing[0];\n\n      for (var m = 1, lenM = validation.missing.length; m < lenM; m++) {\n        missingString += ', ' + validation.missing[m];\n      }\n\n      var err = new Error('Validation schema(s) \"' + missingString + '\" missing!');\n      debug(err);\n      return err;\n    }\n\n    if (!validation.valid) {\n      var errors = validation.errors;\n      var firstError = validation.errors[0];\n      if (firstError.message.indexOf('not match any schemas') >= 0 && firstError.subErrors && firstError.subErrors.length > 0) {\n        firstError = firstError.subErrors[0];\n        errors = firstError.subErrors;\n      }\n      return new ValidationError(firstError.dataPath + ' => ' + firstError.message, errors);\n    }\n\n    return null;\n  };\n}\n\nmodule.exports = getValidator;\n"}